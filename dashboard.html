<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="copyright" content="¬© 2025 Justin A.F.D. Kozak">
    <meta name="license" content="MIT License">
    <title>Operations KPI Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* Tab Styles */
        .tab-container {
            margin-bottom: 30px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-btn {
            padding: 12px 24px;
            background: #f1f5f9;
            border: none;
            border-radius: 8px;
            color: #64748b;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            background: #e2e8f0;
            color: #1e293b;
        }

        .tab-btn.active {
            background: #3b82f6;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.5rem;
            color: #1e293b;
            margin-bottom: 8px;
        }
        
        .subtitle {
            color: #64748b;
            font-size: 1.1rem;
        }
        
        .upload-section {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            background: #3b82f6;
            color: white;
            padding: 12px 30px;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .upload-btn:hover {
            background: #2563eb;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        .file-info {
            margin-top: 15px;
            color: #64748b;
            font-size: 0.9rem;
        }
        
        .filter-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .filter-label {
            font-weight: 600;
            color: #475569;
        }
        
        .period-buttons {
            display: flex;
            gap: 10px;
        }
        
        .period-btn {
            padding: 10px 20px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s;
        }
        
        .period-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        .period-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .date-range input {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 4px solid;
        }
        
        .metric-card.blue { border-left-color: #3b82f6; }
        .metric-card.purple { border-left-color: #a855f7; }
        .metric-card.red { border-left-color: #ef4444; }
        .metric-card.green { border-left-color: #10b981; }
        
        .metric-label {
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        
        .metric-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #1e293b;
        }
        
        .metric-change {
            color: #10b981;
            font-size: 0.85rem;
            font-weight: 600;
            margin-top: 5px;
        }
        
        .date-display {
            color: #64748b;
            font-size: 0.85rem;
            margin-top: 5px;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .chart-title {
            font-size: 1.25rem;
            font-weight: bold;
            color: #1e293b;
            margin-bottom: 20px;
        }

        /* TTM Analytics Styles */
        .chart-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
        }
        
        .ttm-selector {
            flex-shrink: 0;
            width: 220px;
            max-height: 600px;
            overflow-y: auto;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            background: #f8fafc;
        }
        
        .chart-content .chart-container {
            flex: 1;
            min-width: 0;
        }
        
        .ttm-selector h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1rem;
            border-bottom: 2px solid #cbd5e1;
            padding-bottom: 8px;
        }
        
        .ttm-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .ttm-checkbox:hover {
            background: #e2e8f0;
        }
        
        .ttm-checkbox input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }
        
        .ttm-checkbox label {
            cursor: pointer;
            font-size: 0.9rem;
            color: #475569;
            user-select: none;
        }
        
        .select-all-container {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #cbd5e1;
        }
        
        .select-all-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-right: 5px;
            transition: background 0.2s;
        }
        
        .select-all-btn:hover {
            background: #2563eb;
        }
        
        .deselect-all-btn {
            background: #64748b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }
        
        .deselect-all-btn:hover {
            background: #475569;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
        }

        .chart-container.clickable {
            cursor: pointer;
        }
        
        .table-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: #f1f5f9;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #475569;
            border-bottom: 2px solid #e2e8f0;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #f1f5f9;
            color: #64748b;
        }
        
        tr:hover {
            background: #f8fafc;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .badge.green {
            background: #d1fae5;
            color: #065f46;
        }
        
        .badge.yellow {
            background: #fef3c7;
            color: #92400e;
        }
        
        .badge.red {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #1e293b;
            color: #fff;
            text-align: left;
            border-radius: 8px;
            padding: 12px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1e293b transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Footer */
        footer {
            margin-top: 30px;
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 3% auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
        }

        .close {
            color: #64748b;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #ef4444;
        }

        .modal-chart-container {
            position: relative;
            height: 500px;
            margin-bottom: 20px;
        }

        .modal-summary {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Operations KPI Dashboard</h1>
            <p class="subtitle">Warehouse Performance Metrics</p>
        </header>

        <div class="tab-container">
            <div class="tabs">
                <button class="tab-btn active" onclick="showTab('dashboard')">Dashboard</button>
                <button class="tab-btn" onclick="showTab('analytics')">TTM Analytics</button>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <div class="upload-section">
            <div class="file-input-wrapper">
                <div class="tooltip">
                    <label for="excelFile" class="upload-btn">üìÅ Load Excel File</label>
                    <span class="tooltiptext">
                        <strong>Excel File Format:</strong><br>
                        <strong>Sheet "Shipments":</strong> Date, TTM, Customer, Boxes Picked, Pallets Picked, ft¬≤<br>
                        <strong>Sheet "Errors":</strong> Date, TTM<br>
                        (Accuracy calculated as: error count / shipment count)
                    </span>
                </div>
                <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleFileUpload(event)">
            </div>
            <div class="file-info" id="fileInfo">No file loaded. Using sample data.</div>
        </div>
        
        <div class="filter-section">
            <span class="filter-label">View:</span>
            <div class="period-buttons">
                <button class="period-btn active" onclick="setPeriod('daily')">Daily</button>
                <button class="period-btn" onclick="setPeriod('weekly')">Weekly</button>
                <button class="period-btn" onclick="setPeriod('monthly')">Monthly</button>
            </div>
            <span class="filter-label" style="margin-left: 20px;">Date Range:</span>
            <div class="date-range">
                <input type="date" id="startDate" onchange="updateDashboard()">
                <span>to</span>
                <input type="date" id="endDate" onchange="updateDashboard()">
            </div>
        </div>
        
        <div class="metrics-grid">
            <div class="metric-card blue">
                <div class="metric-label">Total Boxes Picked</div>
                <div class="metric-value" id="totalBoxes">-</div>
                <div class="date-display" id="boxesDateRange"></div>
            </div>
            <div class="metric-card purple">
                <div class="metric-label">Total Pallets</div>
                <div class="metric-value" id="totalPallets">-</div>
                <div class="date-display" id="palletsDateRange"></div>
            </div>
            <div class="metric-card green">
                <div class="metric-label">Total ft¬≤ Shipped</div>
                <div class="metric-value" id="totalSqft">-</div>
                <div class="date-display" id="sqftDateRange"></div>
            </div>
            <div class="metric-card blue">
                <div class="metric-label">Total ft¬≤ Received</div>
                <div class="metric-value" id="totalSqftReceived">-</div>
                <div class="date-display" id="sqftReceivedDateRange"></div>
            </div>
            <div class="metric-card red">
                <div class="metric-label">Error Rate</div>
                <div class="metric-value" id="errorRate">-</div>
                <div class="date-display" id="errorDateRange"></div>
            </div>
            <div class="metric-card blue">
                <div class="metric-label">Avg Accuracy</div>
                <div class="metric-value" id="avgAccuracy">-</div>
                <div class="date-display" id="accuracyDateRange"></div>
            </div>
        </div>
        
        <div class="charts-grid">
            <div class="chart-card">
                <h3 class="chart-title">üì¶ Boxes Picked by Employee</h3>
                <div class="chart-container">
                    <canvas id="boxesChart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">üöö Pallets Picked by Employee</h3>
                <div class="chart-container">
                    <canvas id="palletsChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="chart-card" style="margin-bottom: 30px;">
            <h3 class="chart-title">üìè Square Footage Picked by Employee Over Time</h3>
            <div style="position: relative; height: 400px;">
                <canvas id="sqftTrendChart"></canvas>
            </div>
        </div>
        
        <div class="charts-grid">
            <div class="chart-card">
                <h3 class="chart-title">üìà Productivity Trend Over Time</h3>
                <div class="chart-container">
                    <canvas id="trendChart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">‚ö†Ô∏è Errors by Employee</h3>
                <div class="chart-container">
                    <canvas id="errorsChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="chart-card" style="margin-bottom: 30px;">
            <h3 class="chart-title">üìÖ Average Ft¬≤ Picked by Weekday (Click for Customer Breakdown)</h3>
            <div class="chart-container clickable">
                <canvas id="weekdayChart"></canvas>
            </div>
        </div>
        
        <div class="table-card">
            <h3 class="chart-title">Employee Performance Details</h3>
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>Employee</th>
                        <th>Boxes</th>
                        <th>Pallets</th>
                        <th>Errors</th>
                        <th>Sq Ft Shipped</th>
                        <th>Accuracy</th>
                        <th>Lines Shipped</th>
                        <th># Pallets Rcvd</th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>

        </div>

        <!-- Analytics Tab -->
        <div id="analytics-tab" class="tab-content">
            <div class="upload-section">
                <div class="file-input-wrapper">
                    <div class="tooltip">
                        <label for="excelFile" class="upload-btn">üìÅ Load Excel File</label>
                        <span class="tooltiptext">
                            <strong>Excel File Format:</strong><br>
                            <strong>Sheet "Shipments":</strong> Date, TTM, Customer, Boxes Picked, Pallets Picked, ft¬≤<br>
                            <strong>Sheet "Errors":</strong> Date, TTM<br>
                            (Accuracy calculated as: error count / shipment count)
                        </span>
                    </div>
                </div>
                <div class="file-info" id="fileInfo2">No file loaded. Using sample data.</div>
            </div>

            <div class="filter-section">
                <span class="filter-label">Date Range:</span>
                <div class="date-range">
                    <input type="date" id="startDate2" onchange="updateAnalytics()">
                    <span>to</span>
                    <input type="date" id="endDate2" onchange="updateAnalytics()">
                </div>
            </div>

            <div class="chart-card">
                <h3 class="chart-title">TTM ft¬≤ Picked vs Median (Excluding values below 2,000 ft¬≤)</h3>
                <div class="chart-content">
                    <div class="ttm-selector">
                        <h4>Select TTMs</h4>
                        <div class="select-all-container">
                            <button class="select-all-btn" onclick="selectAllTTMs()">Select All</button>
                            <button class="deselect-all-btn" onclick="deselectAllTTMs()">Deselect All</button>
                        </div>
                        <div id="ttmCheckboxes"></div>
                    </div>
                    <div class="chart-container" style="height: 600px;">
                        <canvas id="ttmChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            ¬© 2025 Justin A.F.D. Kozak
        </footer>
    </div>

    <!-- Customer Breakdown Modal -->
    <div id="customerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Customer Breakdown</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-chart-container">
                <canvas id="customerPieChart"></canvas>
            </div>
            <div class="modal-summary" id="modalSummary">
                <!-- Summary will be populated dynamically -->
            </div>
        </div>
    </div>

    <script>
        let charts = {};
        let allData = [];
        let allErrors = [];
        let allReceived = [];
        let ttmChart = null;
        let selectedTTMs = new Set();
        let currentPeriod = 'daily';
        let customerModalChart = null;
        
        // Sample data with dates
        function generateSampleData() {
            const employees = ['John M.', 'Sarah K.', 'Mike R.', 'Lisa P.', 'David L.', 'Emma W.'];
            const customers = ['Acme Corp', 'Tech Solutions Inc', 'Global Industries', 'MegaMart', 'Supply Chain Co', 'Retail Giant', 'Manufacturing Ltd', 'Distribution Pro', 'Logistics Plus', 'Warehouse Direct', 'Quick Ship', 'Fast Track'];
            const data = [];
            const today = new Date();
            
            // Generate 30 days of data
            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                
                employees.forEach(emp => {
                    // Each employee has multiple shipment lines per day
                    const numShipments = Math.floor(Math.random() * 3) + 2; // 2-4 shipments per day
                    for (let j = 0; j < numShipments; j++) {
                        data.push({
                            date: date.toISOString().split('T')[0],
                            name: emp,
                            customer: customers[Math.floor(Math.random() * customers.length)],
                            boxes: Math.floor(Math.random() * 50) + 50,
                            pallets: Math.floor(Math.random() * 5) + 3,
                            sqft: Math.floor(Math.random() * 500) + 500
                        });
                    }
                });
            }
            return data;
        }
        
        function generateSampleErrors() {
            const employees = ['John M.', 'Sarah K.', 'Mike R.', 'Lisa P.', 'David L.', 'Emma W.'];
            const errors = [];
            const today = new Date();
            
            // Generate 30 days of errors (roughly 2-5% error rate)
            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                
                employees.forEach(emp => {
                    // Random number of errors per day (0-2)
                    const numErrors = Math.random() < 0.7 ? Math.floor(Math.random() * 2) : Math.floor(Math.random() * 3);
                    for (let j = 0; j < numErrors; j++) {
                        errors.push({
                            date: date.toISOString().split('T')[0],
                            name: emp
                        });
                    }
                });
            }
            return errors;
        }
        
        // Try to load data from localStorage first
        function loadDataFromStorage() {
            try {
                const storedShipments = localStorage.getItem('shippingData');
                const storedErrors = localStorage.getItem('errorData');
                const storedReceived = localStorage.getItem('receivedData');
                const fileName = localStorage.getItem('dataFileName');
                const loadTime = localStorage.getItem('dataLoadedTime');
                
                if (storedShipments && storedErrors && storedReceived) {
                    allData = JSON.parse(storedShipments);
                    allErrors = JSON.parse(storedErrors);
                    allReceived = JSON.parse(storedReceived);
                    
                if (fileName && loadTime) {
                    const timeLoaded = new Date(loadTime).toLocaleString();
                    document.getElementById('fileInfo').textContent = `‚úì Using cached data: ${fileName} (loaded ${timeLoaded})`;
                    document.getElementById('fileInfo2').textContent = `‚úì Using cached data: ${fileName} (loaded ${timeLoaded})`;
                } else {
                    document.getElementById('fileInfo').textContent = `‚úì Using cached data - ${allData.length} shipment records`;
                    document.getElementById('fileInfo2').textContent = `‚úì Using cached data - ${allData.length} shipment records`;
                }                    console.log('Loaded data from localStorage:', allData.length, 'shipments,', allErrors.length, 'errors,', allReceived.length, 'received');
                    return true;
                }
            } catch (e) {
                console.warn('Could not load data from localStorage:', e);
            }
            return false;
        }
        
        // Load from storage or use sample data
        if (!loadDataFromStorage()) {
            allData = generateSampleData();
            allErrors = generateSampleErrors();
            allReceived = []; // No sample received data
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            document.getElementById('fileInfo').textContent = `Loading ${file.name}...`;
            document.getElementById('fileInfo2').textContent = `Loading ${file.name}...`;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // Debug: Log available sheet names
                    console.log('Available sheets:', workbook.SheetNames);
                    
                    // Look for the "Shipments" sheet specifically
                    const shipmentsSheet = workbook.Sheets['Shipments'];
                    if (!shipmentsSheet) {
                        throw new Error('Sheet "Shipments" not found. Please ensure your Excel file has a sheet named "Shipments". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    // Look for the "Errors" sheet
                    const errorsSheet = workbook.Sheets['Errors'];
                    if (!errorsSheet) {
                        throw new Error('Sheet "Errors" not found. Please ensure your Excel file has a sheet named "Errors". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    // Look for the "Received" sheet
                    const receivedSheet = workbook.Sheets['Received'];
                    if (!receivedSheet) {
                        throw new Error('Sheet "Received" not found. Please ensure your Excel file has a sheet named "Received". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    const jsonData = XLSX.utils.sheet_to_json(shipmentsSheet, {range: 1});// Start parsing from the second row (index 1)
                    const errorsData = XLSX.utils.sheet_to_json(errorsSheet, {range: 1});
                    const receivedData = XLSX.utils.sheet_to_json(receivedSheet, {range: 2}); // Skip extra header row
                    
                    console.log('Raw Shipments data count:', jsonData.length);
                    console.log('Sample row from Excel:', jsonData[0]);
                    console.log('Column names detected:', Object.keys(jsonData[0] || {}));
                    console.log('Raw Errors data count:', errorsData.length);
                    console.log('Sample error row:', errorsData[0]);
                    console.log('Raw Received data count:', receivedData.length);
                    console.log('Sample received row:', receivedData[0]);
                    console.log('Second received row:', receivedData[1]);
                    console.log('Third received row:', receivedData[2]);
                    
                    allData = jsonData.map(row => {
                        let dateValue = row['Date'] || row['date'] || row['DATE'];
                        
                        // Handle Excel date serial numbers
                        if (typeof dateValue === 'number') {
                            const excelEpoch = new Date(1899, 11, 30);
                            const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                            dateValue = date.toISOString().split('T')[0];
                        } else if (dateValue instanceof Date) {
                            dateValue = dateValue.toISOString().split('T')[0];
                        } else if (typeof dateValue === 'string') {
                            // Try to parse string dates
                            const parsed = new Date(dateValue);
                            if (!isNaN(parsed.getTime())) {
                                dateValue = parsed.toISOString().split('T')[0];
                            }
                        }
                        
                        return {
                            date: dateValue,
                            name: row['TTM'] || row['Employee'] || row['Name'] || row['employee'] || row['name'] || 'Unknown',
                            customer: row['Customer'] || row['customer'] || row['CUSTOMER'] || 'Unknown',
                            boxes: parseInt(row['Boxes Picked'] || row['boxes'] || row['BOXES'] || 0),
                            pallets: parseInt(row['Pallets Picked'] || row['pallets'] || row['PALLETS'] || 0),
                            sqft: parseInt(row['ft¬≤'] || row['sqft'] || row['Square Footage'] || row['SQFT'] || row['Sq Ft'] || 0)
                        };
                    });
                    
                    // Process errors data
                    console.log('Processing errors - before mapping:', errorsData.length, 'rows');
                    if (errorsData.length > 0) {
                        console.log('First error row (raw):', errorsData[0]);
                        console.log('Error columns:', Object.keys(errorsData[0]));
                    }
                    
                    const mappedErrors = errorsData.map((row, index) => {
                        // Try multiple possible date column names
                        let dateValue = row['Shipment Date'] || row['Date'] || row['date'] || row['DATE'] || 
                                       row['Date of Error'] || row['Error Date'] ||
                                       row['__EMPTY'] || row['__EMPTY_2'] || row['__EMPTY_3'];
                        
                        // If still no date, try to find any column that looks like a date
                        if (!dateValue) {
                            const keys = Object.keys(row);
                            for (let key of keys) {
                                if (key !== '__EMPTY_1' && row[key]) {
                                    // Check if it's a number (Excel serial date) or looks like a date
                                    if (typeof row[key] === 'number' || 
                                        (typeof row[key] === 'string' && row[key].match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/))) {
                                        dateValue = row[key];
                                        if (index === 0) {
                                            console.log(`Using column "${key}" as date column`);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Handle Excel date serial numbers
                        if (typeof dateValue === 'number') {
                            const excelEpoch = new Date(1899, 11, 30);
                            const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                            dateValue = date.toISOString().split('T')[0];
                        } else if (dateValue instanceof Date) {
                            dateValue = dateValue.toISOString().split('T')[0];
                        } else if (typeof dateValue === 'string') {
                            // Handle MM/DD/YYYY format specifically
                            const mmddyyyyMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                            if (mmddyyyyMatch) {
                                const [, month, day, year] = mmddyyyyMatch;
                                dateValue = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                            } else {
                                // Try standard date parsing
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    dateValue = parsed.toISOString().split('T')[0];
                                }
                            }
                        }
                        
                        // Try multiple possible TTM column names
                        const ttmName = row['TTM'] || row['ttm'] || row['Employee'] || row['employee'] || 
                                       row['Name'] || row['name'] || row['Team Member'] || 
                                       row['__EMPTY_1'] || 'Unknown';
                        
                        if (index === 0) {
                            console.log('First error row processing:');
                            console.log('  Raw row:', row);
                            console.log('  Date value found:', dateValue);
                            console.log('  TTM name found:', ttmName);
                        }
                        
                        return {
                            date: dateValue,
                            name: ttmName
                        };
                    });
                    
                    console.log('Mapped errors before filter:', mappedErrors.length);
                    if (mappedErrors.length > 0) {
                        console.log('First mapped error:', mappedErrors[0]);
                    }
                    
                    // Filter out "ignore" rows AND rows with invalid dates (like header rows)
                    allErrors = mappedErrors.filter(row => {
                        const nameValid = row.name && row.name.toLowerCase() !== 'ignore';
                        const dateValid = row.date && row.date !== 'undefined' && 
                                         !row.date.toLowerCase().includes('auto') &&
                                         !row.date.toLowerCase().includes('date') &&
                                         row.date.match(/\d{4}-\d{2}-\d{2}/); // Must be in YYYY-MM-DD format
                        
                        return nameValid && dateValid;
                    });
                    
                    console.log('After filtering "ignore" and invalid dates:', allErrors.length);
                    if (allErrors.length > 0) {
                        console.log('First error after filter:', allErrors[0]);
                        console.log('Last error after filter:', allErrors[allErrors.length - 1]);
                    } else {
                        console.warn('WARNING: All error rows were filtered out or no errors exist!');
                        console.log('Check if all TTM names are "ignore" or if the TTM column name is incorrect');
                        console.log('Mapped errors before filtering:', mappedErrors.slice(0, 5));
                    }
                    
                    console.log('Processed data sample:', allData[0]);
                    console.log('Total shipment records:', allData.length);
                    console.log('Total error records:', allErrors.length);
                    
                    // Process received data
                    console.log('Processing received data - before mapping:', receivedData.length, 'rows');
                    if (receivedData.length > 0) {
                        console.log('First received row (raw):', receivedData[0]);
                        console.log('Received columns:', Object.keys(receivedData[0]));
                    }
                    
                    const mappedReceived = receivedData.map((row, index) => {
                        let dateValue = row['__EMPTY_8'] || row['Receive Date'] || row['receive date'] || row['Date'] || row['date'] || row['DATE'];
                        
                        // Handle Excel date serial numbers
                        if (typeof dateValue === 'number') {
                            const excelEpoch = new Date(1899, 11, 30);
                            const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                            dateValue = date.toISOString().split('T')[0];
                        } else if (dateValue instanceof Date) {
                            dateValue = dateValue.toISOString().split('T')[0];
                        } else if (typeof dateValue === 'string') {
                            // Handle MM/DD/YYYY format specifically
                            const mmddyyyyMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                            if (mmddyyyyMatch) {
                                const [, month, day, year] = mmddyyyyMatch;
                                dateValue = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                            } else {
                                // Try standard date parsing
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    dateValue = parsed.toISOString().split('T')[0];
                                }
                            }
                        }
                        
                        const sqftValue = row['__EMPTY_6'] || row['ft¬≤'] || row['sqft'] || row['Square Footage'] || row['SQFT'] || row['Sq Ft'];
                        const sqftParsed = parseFloat(sqftValue) || 0;
                        
                        const receiverName = row['__EMPTY_9'] || row['Receiver'] || row['receiver'] || row['TTM'] || 'Unknown';
                        const palletCount = parseFloat(row['__EMPTY_11'] || row['Pallet Count'] || row['pallet count'] || row['Pallets'] || 0) || 0;
                        
                        if (index < 3) {
                            console.log(`Received row ${index}:`, {
                                rawDate: row['__EMPTY_8'] || row['Receive Date'] || row['Date'],
                                parsedDate: dateValue,
                                rawSqft: sqftValue,
                                parsedSqft: sqftParsed,
                                receiver: receiverName,
                                palletCount: palletCount,
                                allKeys: Object.keys(row)
                            });
                        }
                        
                        return {
                            date: dateValue,
                            sqft: sqftParsed,
                            receiver: receiverName,
                            pallets: palletCount
                        };
                    });
                    
                    console.log('Mapped received before filter:', mappedReceived.length);
                    
                    allReceived = mappedReceived.filter(row => {
                        const dateValid = row.date && row.date !== 'undefined' && 
                                         row.date.match(/\d{4}-\d{2}-\d{2}/); // Must be in YYYY-MM-DD format
                        return dateValid;
                    });
                    
                    console.log('Total received records:', allReceived.length);
                    if (allReceived.length > 0) {
                        console.log('First received after processing:', allReceived[0]);
                    }
                    
                    // Set date range based on data
                    const dates = allData.map(d => d.date).filter(d => d).sort();
                    if (dates.length > 0) {
                        document.getElementById('startDate').value = dates[0];
                        document.getElementById('endDate').value = dates[dates.length - 1];
                        document.getElementById('startDate2').value = dates[0];
                        document.getElementById('endDate2').value = dates[dates.length - 1];
                    } else {
                        // If no valid dates, clear the date filters
                        document.getElementById('startDate').value = '';
                        document.getElementById('endDate').value = '';
                        document.getElementById('startDate2').value = '';
                        document.getElementById('endDate2').value = '';
                    }
                    
                    // Store data in localStorage to share with other pages
                    try {
                        localStorage.setItem('shippingData', JSON.stringify(allData));
                        localStorage.setItem('errorData', JSON.stringify(allErrors));
                        localStorage.setItem('receivedData', JSON.stringify(allReceived));
                        localStorage.setItem('dataLoadedTime', new Date().toISOString());
                        localStorage.setItem('dataFileName', file.name);
                    } catch (e) {
                        console.warn('Could not save data to localStorage:', e);
                    }
                    
                    document.getElementById('fileInfo').textContent = `‚úì Loaded ${file.name} - ${allData.length} shipment records, ${allErrors.length} error records, ${allReceived.length} received records`;
                    document.getElementById('fileInfo2').textContent = `‚úì Loaded ${file.name} - ${allData.length} shipment records, ${allErrors.length} error records, ${allReceived.length} received records`;
                    updateDashboard();
                } catch (error) {
                    const errorMsg = `‚ùå Error: ${error.message}`;
                    document.getElementById('fileInfo').textContent = errorMsg;
                    document.getElementById('fileInfo2').textContent = errorMsg;
                    console.error('Full error:', error);
                    console.error('Error stack:', error.stack);
                    alert('Error loading file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function setPeriod(period) {
            currentPeriod = period;
            document.querySelectorAll('.period-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            updateDashboard();
        }
        
        function getFilteredData() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const startDate2 = document.getElementById('startDate2').value;
            const endDate2 = document.getElementById('endDate2').value;
            
            // Use analytics tab dates if on analytics tab
            const activeTab = document.querySelector('.tab-content.active');
            const useAnalyticsDates = activeTab && activeTab.id === 'analytics-tab';
            
            const actualStartDate = useAnalyticsDates ? startDate2 : startDate;
            const actualEndDate = useAnalyticsDates ? endDate2 : endDate;
            
            console.log('Date range - Start:', actualStartDate, 'End:', actualEndDate);
            console.log('All data length:', allData.length);
            
            // If no date filters are set, return all data
            if (!actualStartDate && !actualEndDate) {
                console.log('No date filters - returning all data');
                return allData;
            }
            
            let filtered = allData;
            
            if (actualStartDate) {
                filtered = filtered.filter(d => d.date && d.date >= actualStartDate);
            }
            if (actualEndDate) {
                filtered = filtered.filter(d => d.date && d.date <= actualEndDate);
            }
            
            console.log('After filtering:', filtered.length, 'records');
            
            return filtered;
        }
        
        function getFilteredErrors() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // If no date filters are set, return all errors
            if (!startDate && !endDate) {
                return allErrors;
            }
            
            let filtered = allErrors;
            
            if (startDate) {
                filtered = filtered.filter(d => d.date && d.date >= startDate);
            }
            if (endDate) {
                filtered = filtered.filter(d => d.date && d.date <= endDate);
            }
            
            return filtered;
        }
        
        function getFilteredReceived() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // If no date filters are set, return all received
            if (!startDate && !endDate) {
                return allReceived;
            }
            
            let filtered = allReceived;
            
            if (startDate) {
                filtered = filtered.filter(d => d.date && d.date >= startDate);
            }
            if (endDate) {
                filtered = filtered.filter(d => d.date && d.date <= endDate);
            }
            
            return filtered;
        }
        
        function calculateErrorsAndAccuracy(filteredShipments, filteredErrors) {
            console.log('=== calculateErrorsAndAccuracy ===');
            console.log('Filtered shipments:', filteredShipments.length);
            console.log('Filtered errors:', filteredErrors.length);
            
            // Count errors by TTM
            const errorsByTTM = {};
            filteredErrors.forEach(error => {
                if (!errorsByTTM[error.name]) {
                    errorsByTTM[error.name] = 0;
                }
                errorsByTTM[error.name]++;
            });
            
            // Count shipment lines by TTM
            const shipmentsByTTM = {};
            filteredShipments.forEach(shipment => {
                if (!shipmentsByTTM[shipment.name]) {
                    shipmentsByTTM[shipment.name] = 0;
                }
                shipmentsByTTM[shipment.name]++;
            });
            
            // Calculate accuracy for each TTM (error rate as percentage)
            const accuracyByTTM = {};
            Object.keys(shipmentsByTTM).forEach(name => {
                const errorCount = errorsByTTM[name] || 0;
                const shipmentCount = shipmentsByTTM[name] || 1;
                // Error rate as percentage: (errors / shipments) * 100
                const errorRate = (errorCount / shipmentCount) * 100;
                accuracyByTTM[name] = errorRate.toFixed(2);
            });
            
            console.log('Errors by TTM:', errorsByTTM);
            console.log('Shipments by TTM:', shipmentsByTTM);
            console.log('Accuracy by TTM:', accuracyByTTM);
            
            return {
                errorsByTTM,
                shipmentsByTTM,
                accuracyByTTM
            };
        }
        
        function aggregateByPeriod(data, errorStats, receivedData) {
            const grouped = {};
            
            data.forEach(row => {
                let key;
                const date = new Date(row.date);
                
                if (currentPeriod === 'daily') {
                    key = `${row.name}-${row.date}`;
                } else if (currentPeriod === 'weekly') {
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = `${row.name}-${weekStart.toISOString().split('T')[0]}`;
                } else { // monthly
                    key = `${row.name}-${date.getFullYear()}-${date.getMonth() + 1}`;
                }
                
                if (!grouped[key]) {
                    grouped[key] = {
                        name: row.name,
                        boxes: 0,
                        pallets: 0,
                        sqft: 0,
                        days: 0
                    };
                }
                
                grouped[key].boxes += row.boxes;
                grouped[key].pallets += row.pallets;
                grouped[key].sqft += row.sqft;
                grouped[key].days++;
            });
            
            // Aggregate by employee
            const byEmployee = {};
            Object.values(grouped).forEach(item => {
                if (!byEmployee[item.name]) {
                    byEmployee[item.name] = {
                        name: item.name,
                        boxes: 0,
                        pallets: 0,
                        sqft: 0,
                        days: 0,
                        errors: 0,
                        accuracy: 0,
                        linesShipped: 0,
                        palletsReceived: 0
                    };
                }
                byEmployee[item.name].boxes += item.boxes;
                byEmployee[item.name].pallets += item.pallets;
                byEmployee[item.name].sqft += item.sqft;
                byEmployee[item.name].days += item.days;
            });
            
            // Add error counts, accuracy, and shipment counts from errorStats
            Object.keys(byEmployee).forEach(name => {
                byEmployee[name].errors = errorStats.errorsByTTM[name] || 0;
                byEmployee[name].accuracy = parseFloat(errorStats.accuracyByTTM[name]) || 0;
                byEmployee[name].linesShipped = errorStats.shipmentsByTTM[name] || 0;
            });
            
            // Add pallets received from receivedData
            if (receivedData && receivedData.length > 0) {
                receivedData.forEach(row => {
                    if (row.receiver && byEmployee[row.receiver]) {
                        byEmployee[row.receiver].palletsReceived += row.pallets || 0;
                    }
                });
            }
            
            return Object.values(byEmployee);
        }
        
        function updateDashboard() {
            console.log('=== UPDATE DASHBOARD CALLED ===');
            console.log('allData length:', allData.length);
            console.log('allErrors length:', allErrors.length);
            
            const filteredData = getFilteredData();
            const filteredErrors = getFilteredErrors();
            const filteredReceivedData = getFilteredReceived();
            console.log('Filtered data:', filteredData.length, 'records');
            console.log('Filtered errors:', filteredErrors.length, 'records');
            console.log('Sample filtered record:', filteredData[0]);
            
            if (filteredData.length === 0) {
                console.warn('WARNING: No filtered data available!');
                alert('No data available after filtering. Check your date range or data file.');
                return;
            }
            
            const errorStats = calculateErrorsAndAccuracy(filteredData, filteredErrors);
            const aggregatedData = aggregateByPeriod(filteredData, errorStats, filteredReceivedData);
            console.log('Aggregated data:', aggregatedData.length, 'employees');
            console.log('Sample aggregated record:', aggregatedData[0]);
            
            if (aggregatedData.length === 0) {
                console.warn('WARNING: No aggregated data!');
                alert('No aggregated data available. Check console for details.');
                return;
            }
            
            updateMetrics(aggregatedData, filteredData);
            updateCharts(aggregatedData, filteredData);
            updateTable(aggregatedData);
            console.log('=== DASHBOARD UPDATE COMPLETE ===');
        }
        
        function updateMetrics(data, rawData) {
            const totalBoxes = data.reduce((sum, emp) => sum + emp.boxes, 0);
            const totalPallets = data.reduce((sum, emp) => sum + emp.pallets, 0);
            const totalErrors = data.reduce((sum, emp) => sum + emp.errors, 0);
            const totalSqft = data.reduce((sum, emp) => sum + emp.sqft, 0);
            const totalLinesShipped = data.reduce((sum, emp) => sum + emp.linesShipped, 0);
            // Calculate average error rate then convert to accuracy rate (100 - error rate)
            const avgErrorRate = data.reduce((sum, emp) => sum + parseFloat(emp.accuracy), 0) / data.length;
            const avgAccuracy = (100 - avgErrorRate).toFixed(2);
            const errorRate = totalLinesShipped > 0 ? ((totalErrors / totalLinesShipped) * 100).toFixed(2) : '0.00';
            
            // Calculate total ft¬≤ received
            const filteredReceivedData = getFilteredReceived();
            const totalSqftReceived = filteredReceivedData.reduce((sum, row) => sum + (row.sqft || 0), 0);
            
            const startDate = document.getElementById('startDate').value || 'All';
            const endDate = document.getElementById('endDate').value || 'All';
            const dateRangeText = `${startDate} to ${endDate}`;
            
            document.getElementById('totalBoxes').textContent = totalBoxes.toLocaleString();
            document.getElementById('totalPallets').textContent = totalPallets.toLocaleString();
            document.getElementById('totalSqft').textContent = totalSqft.toLocaleString();
            document.getElementById('totalSqftReceived').textContent = Math.round(totalSqftReceived).toLocaleString();
            document.getElementById('errorRate').textContent = errorRate + '%';
            document.getElementById('avgAccuracy').textContent = avgAccuracy + '%';
            
            document.querySelectorAll('.date-display').forEach(el => {
                el.textContent = dateRangeText;
            });
        }
        
        function updateCharts(data, rawData) {
            // Sort data alphabetically by name
            const sortedData = data.sort((a, b) => a.name.localeCompare(b.name));
            const names = sortedData.map(e => e.name);
            const boxes = sortedData.map(e => e.boxes);
            const pallets = sortedData.map(e => e.pallets);
            const errors = sortedData.map(e => e.errors);
            
            // Destroy existing charts
            Object.values(charts).forEach(chart => chart.destroy());
            
            // Boxes Chart
            charts.boxes = new Chart(document.getElementById('boxesChart'), {
                type: 'bar',
                data: {
                    labels: names,
                    datasets: [{
                        label: 'Boxes',
                        data: boxes,
                        backgroundColor: '#3b82f6',
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
            
            // Pallets Chart
            charts.pallets = new Chart(document.getElementById('palletsChart'), {
                type: 'bar',
                data: {
                    labels: names,
                    datasets: [{
                        label: 'Pallets',
                        data: pallets,
                        backgroundColor: '#a855f7',
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
            
            // Errors Chart
            charts.errors = new Chart(document.getElementById('errorsChart'), {
                type: 'bar',
                data: {
                    labels: names,
                    datasets: [{
                        label: 'Errors',
                        data: errors,
                        backgroundColor: '#ef4444',
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
            
            // Trend Chart - aggregate by date
            const trendData = {};
            rawData.forEach(row => {
                if (!trendData[row.date]) {
                    trendData[row.date] = { boxes: 0, pallets: 0, errors: 0 };
                }
                trendData[row.date].boxes += row.boxes;
                trendData[row.date].pallets += row.pallets;
                trendData[row.date].errors += row.errors;
            });
            
            const sortedDates = Object.keys(trendData).sort();
            const trendBoxes = sortedDates.map(d => trendData[d].boxes);
            const trendPallets = sortedDates.map(d => trendData[d].pallets);
            
            charts.trend = new Chart(document.getElementById('trendChart'), {
                type: 'line',
                data: {
                    labels: sortedDates,
                    datasets: [
                        {
                            label: 'Boxes',
                            data: trendBoxes,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Pallets',
                            data: trendPallets,
                            borderColor: '#a855f7',
                            backgroundColor: 'rgba(168, 85, 247, 0.1)',
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
            
            // Square Footage Trend by Employee - use filtered data
            const filteredData = getFilteredData();
            const sqftByEmployee = {};
            filteredData.forEach(row => {
                if (!sqftByEmployee[row.name]) {
                    sqftByEmployee[row.name] = {};
                }
                if (!sqftByEmployee[row.name][row.date]) {
                    sqftByEmployee[row.name][row.date] = 0;
                }
                sqftByEmployee[row.name][row.date] += row.sqft;
            });
            
            // Get all unique dates from filtered data and sort them
            const allDatesSet = new Set();
            filteredData.forEach(row => allDatesSet.add(row.date));
            const allDates = Array.from(allDatesSet).sort();
            
            // Calculate total shipped per date (sum of all employees)
            const totalShippedPerDate = allDates.map(date => {
                return filteredData
                    .filter(row => row.date === date)
                    .reduce((sum, row) => sum + row.sqft, 0);
            });
            
            // Calculate received per date
            const receivedDataForTrend = getFilteredReceived();
            const receivedPerDate = allDates.map(date => {
                const received = receivedDataForTrend
                    .filter(row => row.date === date)
                    .reduce((sum, row) => sum + row.sqft, 0);
                return received > 0 ? received : null;
            });
            
            // Sort employee names alphabetically
            const sortedEmployeeNames = Object.keys(sqftByEmployee).sort((a, b) => a.localeCompare(b));
            
            const colors = ['#3b82f6', '#a855f7', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6'];
            const sqftDatasets = sortedEmployeeNames.map((empName, idx) => {
                const empData = sqftByEmployee[empName];
                const dataPoints = allDates.map(date => empData[date] || null);
                
                return {
                    label: empName,
                    data: dataPoints,
                    borderColor: colors[idx % colors.length],
                    backgroundColor: colors[idx % colors.length] + '20',
                    tension: 0.4,
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    spanGaps: true,
                    type: 'line',
                    order: 1
                };
            });
            
            // Add background datasets for received (dark red) and shipped (dark green)
            sqftDatasets.unshift({
                label: 'Shaded Area: ft¬≤ Received',
                data: receivedPerDate,
                backgroundColor: 'rgba(220, 38, 38, 0.7)', // Dark red with 70% opacity
                borderColor: 'rgba(220, 38, 38, 0.7)',
                type: 'bar',
                order: 3,
                barThickness: 'flex'
            });
            
            sqftDatasets.unshift({
                label: 'Shaded Area: ft¬≤ Shipped',
                data: totalShippedPerDate,
                backgroundColor: 'rgba(22, 163, 74, 0.7)', // Dark green with 70% opacity
                borderColor: 'rgba(22, 163, 74, 0.7)',
                type: 'bar',
                order: 2,
                barThickness: 'flex'
            });
            
            charts.sqftTrend = new Chart(document.getElementById('sqftTrendChart'), {
                type: 'line',
                data: {
                    labels: allDates,
                    datasets: sqftDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true, 
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxTicksLimit: 15
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Square Footage'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
            
            // Weekday Average Chart - aggregate by unique dates first
            const dailyTotals = {};
            
            // First, sum up all ft¬≤ for each unique date
            filteredData.forEach(row => {
                if (row.date) {
                    if (!dailyTotals[row.date]) {
                        dailyTotals[row.date] = 0;
                    }
                    dailyTotals[row.date] += row.sqft;
                }
            });
            
            // Process received data for weekday chart
            const receivedDataForWeekday = getFilteredReceived();
            const dailyReceived = {};
            receivedDataForWeekday.forEach(row => {
                if (row.date) {
                    if (!dailyReceived[row.date]) {
                        dailyReceived[row.date] = 0;
                    }
                    dailyReceived[row.date] += row.sqft;
                }
            });
            
            // Then group by weekday
            const weekdayData = {
                'Sunday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Monday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Tuesday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Wednesday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Thursday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Friday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Saturday': { total: 0, count: 0, received: 0, receivedCount: 0 }
            };
            
            const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            Object.keys(dailyTotals).forEach(dateStr => {
                // Parse date manually to avoid timezone issues
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dayName = weekdayNames[date.getDay()];
                weekdayData[dayName].total += dailyTotals[dateStr];
                weekdayData[dayName].count += 1;
            });
            
            Object.keys(dailyReceived).forEach(dateStr => {
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dayName = weekdayNames[date.getDay()];
                weekdayData[dayName].received += dailyReceived[dateStr];
                weekdayData[dayName].receivedCount += 1;
            });
            
            const weekdayAverages = weekdayNames.map(day => {
                return weekdayData[day].count > 0 
                    ? Math.round(weekdayData[day].total / weekdayData[day].count)
                    : 0;
            });
            
            const weekdayReceivedAverages = weekdayNames.map(day => {
                return weekdayData[day].receivedCount > 0 
                    ? Math.round(weekdayData[day].received / weekdayData[day].receivedCount)
                    : 0;
            });
            
            charts.weekday = new Chart(document.getElementById('weekdayChart'), {
                type: 'bar',
                data: {
                    labels: weekdayNames,
                    datasets: [
                        {
                            label: 'Shaded Area: ft¬≤ Received',
                            data: weekdayReceivedAverages,
                            backgroundColor: 'rgba(220, 38, 38, 0.7)', // Dark red with 70% opacity
                            borderRadius: 6,
                            order: 2
                        },
                        {
                            label: 'Average Ft¬≤ Picked',
                            data: weekdayAverages,
                            backgroundColor: ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#a855f7', '#ec4899', '#8b5cf6'],
                            borderRadius: 6,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const day = weekdayNames[context.dataIndex];
                                    const count = weekdayData[day].count;
                                    if (context.datasetIndex === 0) {
                                        return `Avg Received: ${context.parsed.y.toLocaleString()} ft¬≤ (${weekdayData[day].receivedCount} days)`;
                                    } else {
                                        return `Avg Picked: ${context.parsed.y.toLocaleString()} ft¬≤ (${count} days) - Click for customer breakdown`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Average Square Footage'
                            }
                        }
                    },
                    onClick: function(event, elements) {
                        if (elements.length > 0) {
                            const clickedElement = elements[0];
                            const dayName = weekdayNames[clickedElement.index];
                            openModal(dayName);
                        }
                    }
                }
            });
            
        }
        
        function updateTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';
            
            // Sort data alphabetically by name
            const sortedData = data.sort((a, b) => a.name.localeCompare(b.name));
            
            sortedData.forEach(emp => {
                const row = tbody.insertRow();
                // Convert error rate to accuracy rate: 100 - error rate
                const errorRate = parseFloat(emp.accuracy);
                const accuracyRate = 100 - errorRate;
                // Higher accuracy is better
                const accuracyBadge = accuracyRate >= 97 ? 'green' : accuracyRate >= 95 ? 'yellow' : 'red';
                row.innerHTML = `
                    <td><strong>${emp.name}</strong></td>
                    <td>${emp.boxes.toLocaleString()}</td>
                    <td>${emp.pallets}</td>
                    <td><span class="badge ${emp.errors <= 2 ? 'green' : emp.errors <= 5 ? 'yellow' : 'red'}">${emp.errors}</span></td>
                    <td>${emp.sqft.toLocaleString()}</td>
                    <td><span class="badge ${accuracyBadge}">${accuracyRate.toFixed(2)}%</span></td>
                    <td>${emp.linesShipped}</td>
                    <td>${Math.round(emp.palletsReceived || 0)}</td>
                `;
            });
            
            // Add totals row
            const totalBoxes = sortedData.reduce((sum, emp) => sum + emp.boxes, 0);
            const totalPallets = sortedData.reduce((sum, emp) => sum + emp.pallets, 0);
            const totalErrors = sortedData.reduce((sum, emp) => sum + emp.errors, 0);
            const totalSqft = sortedData.reduce((sum, emp) => sum + emp.sqft, 0);
            // Calculate average error rate then convert to accuracy rate
            const avgErrorRate = sortedData.reduce((sum, emp) => sum + parseFloat(emp.accuracy), 0) / sortedData.length;
            const avgAccuracy = (100 - avgErrorRate).toFixed(2);
            const totalLinesShipped = sortedData.reduce((sum, emp) => sum + emp.linesShipped, 0);
            const totalPalletsReceived = sortedData.reduce((sum, emp) => sum + (emp.palletsReceived || 0), 0);
            
            const totalRow = tbody.insertRow();
            totalRow.style.background = '#f1f5f9';
            totalRow.style.fontWeight = 'bold';
            totalRow.innerHTML = `
                <td>TOTAL</td>
                <td>${totalBoxes.toLocaleString()}</td>
                <td>${totalPallets}</td>
                <td>${totalErrors}</td>
                <td>${totalSqft.toLocaleString()}</td>
                <td>${avgAccuracy}%</td>
                <td>${totalLinesShipped}</td>
                <td>${Math.round(totalPalletsReceived)}</td>
            `;
        }
        
        // Modal functions
        function openModal(dayName) {
            const modal = document.getElementById('customerModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalSummary = document.getElementById('modalSummary');
            
            modalTitle.textContent = `Customer Breakdown - ${dayName}`;
            
            // Calculate customer data for the selected day
            const filteredData = getFilteredData();
            const customerData = {};
            const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayIndex = weekdayNames.indexOf(dayName);
            
            filteredData.forEach(row => {
                if (row.customer && row.customer !== 'Unknown' && row.date) {
                    const [year, month, day] = row.date.split('-').map(Number);
                    const date = new Date(year, month - 1, day);
                    if (date.getDay() === dayIndex) {
                        if (!customerData[row.customer]) {
                            customerData[row.customer] = 0;
                        }
                        customerData[row.customer] += row.sqft;
                    }
                }
            });
            
            // Sort customers by volume and get top 14
            const sortedCustomers = Object.keys(customerData)
                .sort((a, b) => customerData[b] - customerData[a]);
            
            const top14Customers = sortedCustomers.slice(0, 14);
            const otherCustomers = sortedCustomers.slice(14);
            
            const totalSqft = Object.values(customerData).reduce((sum, val) => sum + val, 0);
            
            // Calculate "Other" total
            const otherTotal = otherCustomers.reduce((sum, customer) => sum + customerData[customer], 0);
            
            // Create pie chart data
            const pieData = top14Customers.map(customer => ({
                label: customer,
                value: customerData[customer],
                percentage: ((customerData[customer] / totalSqft) * 100).toFixed(1)
            }));
            
            // Add "Other" category if there are additional customers
            if (otherTotal > 0) {
                pieData.push({
                    label: 'Other',
                    value: otherTotal,
                    percentage: ((otherTotal / totalSqft) * 100).toFixed(1)
                });
            }
            
            // Update summary
            const topCustomer = pieData[0];
            const otherCategory = pieData.find(item => item.label === 'Other');
            const individualCustomers = pieData.filter(item => item.label !== 'Other').length;
            
            modalSummary.innerHTML = `
                <strong>Summary for ${dayName}:</strong><br>
                Total ft¬≤: ${totalSqft.toLocaleString()}<br>
                Top Customer: ${topCustomer ? topCustomer.label : 'N/A'} (${topCustomer ? topCustomer.percentage : '0'}%)<br>
                Individual Customers Shown: ${individualCustomers}<br>
                ${otherCategory ? `Other Customers: ${otherCategory.percentage}%` : ''}
            `;
            
            // Create pie chart
            if (customerModalChart) {
                customerModalChart.destroy();
            }
            
            const colors = [
                '#3b82f6', '#a855f7', '#10b981', '#f59e0b', '#ef4444', 
                '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#84cc16',
                '#06b6d4', '#8b5a2b', '#dc2626', '#7c3aed', '#059669',
                '#6b7280'  // Gray color for "Other" category
            ];
            
            customerModalChart = new Chart(document.getElementById('customerPieChart'), {
                type: 'pie',
                data: {
                    labels: pieData.map(item => item.label),
                    datasets: [{
                        data: pieData.map(item => item.value),
                        backgroundColor: colors.slice(0, pieData.length),
                        borderColor: '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = pieData[context.dataIndex];
                                    return `${item.label}: ${item.value.toLocaleString()} ft¬≤ (${item.percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
            
            modal.style.display = 'block';
        }
        
        function closeModal() {
            const modal = document.getElementById('customerModal');
            modal.style.display = 'none';
            if (customerModalChart) {
                customerModalChart.destroy();
                customerModalChart = null;
            }
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('customerModal');
            if (event.target === modal) {
                closeModal();
            }
        }

        // Tab functions
        function showTab(tabId) {
            // Update button states
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.toLowerCase().includes(tabId)) {
                    btn.classList.add('active');
                }
            });

            // Update content visibility
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(`${tabId}-tab`).classList.add('active');

            // Update charts if needed
            if (tabId === 'analytics') {
                updateAnalytics();
            } else {
                updateDashboard();
            }
        }

        // TTM Analytics functions
        function populateTTMCheckboxes() {
            const filteredData = getFilteredData();
            
            // Get unique TTM names
            const ttmData = {};
            filteredData.forEach(row => {
                if (!ttmData[row.name]) {
                    ttmData[row.name] = 0;
                }
                ttmData[row.name] += row.sqft;
            });
            
            const ttmNames = Object.keys(ttmData).sort((a, b) => a.localeCompare(b));
            
            // If this is the first time or all TTMs were selected, select all
            if (selectedTTMs.size === 0) {
                ttmNames.forEach(name => selectedTTMs.add(name));
            }
            
            // Create checkboxes
            const container = document.getElementById('ttmCheckboxes');
            container.innerHTML = '';
            
            ttmNames.forEach(name => {
                const div = document.createElement('div');
                div.className = 'ttm-checkbox';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `ttm-${name.replace(/\s+/g, '-')}`;
                checkbox.value = name;
                checkbox.checked = selectedTTMs.has(name);
                checkbox.onchange = function() {
                    if (this.checked) {
                        selectedTTMs.add(name);
                    } else {
                        selectedTTMs.delete(name);
                    }
                    updateTTMChart();
                };
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = name;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
        }

        function selectAllTTMs() {
            const checkboxes = document.querySelectorAll('#ttmCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                selectedTTMs.add(cb.value);
            });
            updateTTMChart();
        }

        function deselectAllTTMs() {
            const checkboxes = document.querySelectorAll('#ttmCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                selectedTTMs.delete(cb.value);
            });
            updateTTMChart();
        }

        function updateAnalytics() {
            populateTTMCheckboxes();
            updateTTMChart();
        }

        function updateTTMChart() {
            const filteredData = getFilteredData();
            
            // Aggregate ft¬≤ by TTM
            const ttmData = {};
            filteredData.forEach(row => {
                if (!ttmData[row.name]) {
                    ttmData[row.name] = 0;
                }
                ttmData[row.name] += row.sqft;
            });
            
            // Convert to array and sort alphabetically
            let ttmArray = Object.keys(ttmData).map(name => ({
                name: name,
                sqft: ttmData[name]
            })).sort((a, b) => a.name.localeCompare(b.name));
            
            // Filter to only show selected TTMs
            ttmArray = ttmArray.filter(item => selectedTTMs.has(item.name));
            
            // Calculate median ONLY from selected TTMs (excluding values below 2000)
            const validSqftValues = ttmArray
                .map(item => item.sqft)
                .filter(sqft => sqft >= 2000)
                .sort((a, b) => a - b);
            
            let median = 0;
            if (validSqftValues.length > 0) {
                const mid = Math.floor(validSqftValues.length / 2);
                if (validSqftValues.length % 2 === 0) {
                    median = (validSqftValues[mid - 1] + validSqftValues[mid]) / 2;
                } else {
                    median = validSqftValues[mid];
                }
            }
            
            // Calculate percentage difference from median for each TTM
            const percentDifferences = ttmArray.map(item => {
                if (median === 0) return 0;
                return ((item.sqft - median) / median) * 100;
            });
            
            // Prepare chart data
            const labels = ttmArray.map(item => item.name);
            const sqftValues = ttmArray.map(item => item.sqft);
            
            // Create colors based on whether above or below median
            const barColors = sqftValues.map(sqft => 
                sqft >= median ? '#10b981' : '#ef4444'
            );
            
            // Destroy existing chart if it exists
            if (ttmChart) {
                ttmChart.destroy();
            }
            
            // Create the chart
            const ctx = document.getElementById('ttmChart').getContext('2d');
            ttmChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'ft¬≤ Picked',
                            data: sqftValues,
                            backgroundColor: barColors,
                            borderRadius: 6,
                            borderWidth: 2,
                            borderColor: barColors
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const sqft = context.parsed.y;
                                    const percentDiff = percentDifferences[context.dataIndex];
                                    const sign = percentDiff >= 0 ? '+' : '';
                                    return [
                                        `ft¬≤: ${sqft.toLocaleString()}`,
                                        `Median: ${Math.round(median).toLocaleString()}`,
                                        `Difference: ${sign}${percentDiff.toFixed(1)}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Square Footage (ft¬≤)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Team Members',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'medianLinePlugin',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const yScale = chart.scales.y;
                        
                        // Draw median line
                        const yPos = yScale.getPixelForValue(median);
                        
                        ctx.save();
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yPos);
                        ctx.lineTo(chartArea.right, yPos);
                        ctx.stroke();
                        ctx.restore();
                        
                        // Draw median label
                        ctx.save();
                        ctx.fillStyle = '#3b82f6';
                        ctx.font = 'bold 12px sans-serif';
                        const text = `Median: ${Math.round(median).toLocaleString()} ft¬≤`;
                        const textWidth = ctx.measureText(text).width;
                        const padding = 8;
                        const labelX = chartArea.right - textWidth - padding * 2;
                        const labelY = yPos - 20;
                        
                        // Background
                        ctx.fillRect(labelX - padding, labelY - 12, textWidth + padding * 2, 20);
                        
                        // Text
                        ctx.fillStyle = 'white';
                        ctx.fillText(text, labelX, labelY);
                        ctx.restore();
                    },
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;
                        
                        // Draw percentage labels on each bar
                        ctx.save();
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'center';
                        
                        chart.data.labels.forEach((label, index) => {
                            const meta = chart.getDatasetMeta(0);
                            const bar = meta.data[index];
                            const percentDiff = percentDifferences[index];
                            const sign = percentDiff >= 0 ? '+' : '';
                            const text = `${sign}${percentDiff.toFixed(1)}%`;
                            
                            // Position the text above the bar
                            const x = bar.x;
                            const y = bar.y - 10;
                            
                            // Set color based on above/below median
                            ctx.fillStyle = percentDiff >= 0 ? '#10b981' : '#ef4444';
                            ctx.fillText(text, x, y);
                        });
                        
                        ctx.restore();
                    }
                }]
            });
        }

        // Initialize with sample data
        const today = new Date().toISOString().split('T')[0];
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);
        document.getElementById('startDate').value = thirtyDaysAgo.toISOString().split('T')[0];
        document.getElementById('endDate').value = today;
        document.getElementById('startDate2').value = thirtyDaysAgo.toISOString().split('T')[0];
        document.getElementById('endDate2').value = today;
        
        updateDashboard();
    </script>
</body>
</html>