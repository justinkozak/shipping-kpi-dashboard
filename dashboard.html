<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="copyright" content="¬© 2025 Justin A.F.D. Kozak">
    <meta name="license" content="MIT License">
    <title>Operations KPI Dashboard</title>
    
    <!-- External Libraries -->
    <!-- XLSX.js for Excel file parsing - reads .xlsx files and converts sheets to JSON -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    
    <!-- Chart.js for data visualization - creates interactive charts and graphs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
    <style>
        /* ========================================
           GLOBAL STYLES
           ======================================== */
        
        /* Reset default browser styles for consistent rendering across browsers */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* ========================================
           TAB NAVIGATION STYLES
           ======================================== */
        
        /* Tab Styles - Creates tabbed interface for Dashboard and TTM Analytics pages */
        .tab-container {
            margin-bottom: 30px;
        }

        /* Horizontal layout for tab buttons */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        /* Individual tab button styling */
        .tab-btn {
            padding: 12px 24px;
            background: #f1f5f9;  /* Light gray when inactive */
            border: none;
            border-radius: 8px;
            color: #64748b;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;  /* Smooth transition for hover and active states */
        }

        /* Tab button hover effect */
        .tab-btn:hover {
            background: #e2e8f0;  /* Slightly darker gray on hover */
            color: #1e293b;
        }

        /* Active tab styling - blue background with white text */
        .tab-btn.active {
            background: #3b82f6;  /* Change this color to customize active tab appearance */
            color: white;
        }

        /* Hide inactive tab content */
        .tab-content {
            display: none;
        }

        /* Show active tab content */
        .tab-content.active {
            display: block;
        }
        
        /* ========================================
           PAGE LAYOUT & TYPOGRAPHY
           ======================================== */
        
        body {
            /* System font stack for native look on each OS */
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            /* Gradient background from light to slightly darker gray */
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 20px;
            min-height: 100vh;  /* Full viewport height minimum */
        }
        
        /* Main content container with max width for readability */
        .container {
            max-width: 1400px;  /* Adjust this to change page width (e.g., 1600px for wider layout) */
            margin: 0 auto;
        }
        
        header {
            margin-bottom: 30px;
        }
        
        /* Main page title */
        h1 {
            font-size: 2.5rem;  /* Change to 3rem for larger title */
            color: #1e293b;
            margin-bottom: 8px;
        }
        
        /* Subtitle text below main title */
        .subtitle {
            color: #64748b;
            font-size: 1.1rem;
        }
        
        /* ========================================
           FILE UPLOAD SECTION
           ======================================== */
        
        /* Container for file upload area */
        .upload-section {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            text-align: center;
        }
        
        /* Wrapper for custom file input button */
        .file-input-wrapper {
            position: relative;
            display: inline-block;
        }
        
        /* Hide default file input (replaced with custom button) */
        input[type="file"] {
            display: none;
        }
        
        /* Custom upload button styling */
        .upload-btn {
            background: #3b82f6;  /* Blue - change to #10b981 for green, #8b5cf6 for purple */
            color: white;
            padding: 12px 30px;
            border-radius: 8px;
            border: none;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        /* Upload button hover effect with lift animation */
        .upload-btn:hover {
            background: #2563eb;  /* Darker blue on hover */
            transform: translateY(-2px);  /* Lift effect */
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        /* File information display text */
        .file-info {
            margin-top: 15px;
            color: #64748b;
            font-size: 0.9rem;
        }
        
        /* ========================================
           DATE FILTER & PERIOD SELECTION
           ======================================== */
        
        /* Container for date filters and period buttons */
        .filter-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;  /* Wrap to multiple lines on smaller screens */
        }
        
        /* Label styling for filter section */
        .filter-label {
            font-weight: 600;
            color: #475569;
        }
        
        /* Container for Daily/Weekly/Monthly buttons */
        .period-buttons {
            display: flex;
            gap: 10px;
        }
        
        /* Individual period button (Daily, Weekly, Monthly) */
        .period-btn {
            padding: 10px 20px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #64748b;
            transition: all 0.3s;
        }
        
        /* Period button hover state */
        .period-btn:hover {
            border-color: #3b82f6;
            color: #3b82f6;
        }
        
        /* Active period button styling */
        .period-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }
        
        /* Container for start and end date inputs */
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        /* Date input field styling */
        .date-range input {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 0.9rem;
        }
        
        /* ========================================
           METRIC CARDS (KPI TILES)
           ======================================== */
        
        /* Grid layout for metric cards - auto-fits to screen width */
        .metrics-grid {
            display: grid;
            /* Minimum 250px per card, fills available space. Change minmax(250px, 1fr) to minmax(300px, 1fr) for larger cards */
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        /* Individual metric card styling */
        .metric-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-left: 4px solid;  /* Colored left border for visual distinction */
        }
        
        /* Clickable metric cards (used for Statistics tiles) */
        .metric-card.clickable {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        /* Hover effect for clickable cards - lifts card */
        .metric-card.clickable:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        }
        
        /* Color classes for left border - customize these hex values to change card colors */
        .metric-card.blue { border-left-color: #3b82f6; }
        .metric-card.purple { border-left-color: #a855f7; }
        .metric-card.red { border-left-color: #ef4444; }
        .metric-card.green { border-left-color: #10b981; }
        
        /* Metric card label text (e.g., "Total Boxes") */
        .metric-label {
            color: #64748b;
            font-size: 0.9rem;
            margin-bottom: 8px;
        }
        
        /* Large number display in metric cards */
        .metric-value {
            font-size: 2.5rem;  /* Adjust to 3rem for larger numbers */
            font-weight: bold;
            color: #1e293b;
        }
        
        /* Optional metric change indicator (e.g., "+5.2%") */
        .metric-change {
            color: #10b981;  /* Green for positive change */
            font-size: 0.85rem;
            font-weight: 600;
            margin-top: 5px;
        }
        
        /* Date range display text in metric cards */
        .date-display {
            color: #64748b;
            font-size: 0.85rem;
            margin-top: 5px;
        }
        
        /* ========================================
           CHART CARDS & CONTAINERS
           ======================================== */
        
        /* Grid layout for chart cards - responsive 2-column layout */
        .charts-grid {
            display: grid;
            /* Minimum 500px per chart. Change to minmax(400px, 1fr) for smaller charts */
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        /* Individual chart card container */
        .chart-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        /* Chart title styling */
        .chart-title {
            font-size: 1.25rem;
            font-weight: bold;
            color: #1e293b;
            margin-bottom: 20px;
        }

        /* ========================================
           TTM ANALYTICS - CHECKBOX SELECTOR
           ======================================== */
        /* Flexbox container for chart with sidebar selector */
        .chart-content {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            width: 100%;
        }
        
        /* TTM/Employee checkbox selector sidebar */
        .ttm-selector {
            flex-shrink: 0;
            width: 220px;  /* Change to 250px for wider selector */
            max-height: 600px;  /* Adjust to 800px for taller selector */
            overflow-y: auto;  /* Scrollable if content exceeds max-height */
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            padding: 15px;
            background: #f8fafc;
        }
        
        /* Chart container takes remaining space */
        .chart-content .chart-container {
            flex: 1;
            min-width: 0;  /* Prevents flex item from overflowing */
        }
        
        /* Selector section heading */
        .ttm-selector h4 {
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 1rem;
            border-bottom: 2px solid #cbd5e1;
            padding-bottom: 8px;
        }
        
        /* Individual checkbox item in selector */
        .ttm-checkbox {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .ttm-checkbox:hover {
            background: #e2e8f0;
        }
        
        .ttm-checkbox input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
        }
        
        .ttm-checkbox label {
            cursor: pointer;
            font-size: 0.9rem;
            color: #475569;
            user-select: none;
        }
        
        .select-all-container {
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #cbd5e1;
        }
        
        .select-all-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            margin-right: 5px;
            transition: background 0.2s;
        }
        
        .select-all-btn:hover {
            background: #2563eb;
        }
        
        .deselect-all-btn {
            background: #64748b;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }
        
        .deselect-all-btn:hover {
            background: #475569;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
        }

        .chart-container.clickable {
            cursor: pointer;
        }
        
        .table-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: #f1f5f9;
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #475569;
            border-bottom: 2px solid #e2e8f0;
        }
        
        th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        
        th.sortable:hover {
            background: #e2e8f0;
        }
        
        .sort-indicator {
            display: inline-block;
            margin-left: 5px;
            font-size: 0.7em;
            opacity: 0.3;
        }
        
        th.sortable.active .sort-indicator {
            opacity: 1;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #f1f5f9;
            color: #64748b;
        }
        
        tr:hover {
            background: #f8fafc;
        }
        
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .badge.green {
            background: #d1fae5;
            color: #065f46;
        }
        
        .badge.yellow {
            background: #fef3c7;
            color: #92400e;
        }
        
        .badge.red {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: #1e293b;
            color: #fff;
            text-align: left;
            border-radius: 8px;
            padding: 12px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.85rem;
            line-height: 1.4;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1e293b transparent transparent transparent;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        /* Footer */
        footer {
            margin-top: 30px;
            text-align: center;
            color: #64748b;
            font-size: 0.9rem;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: white;
            margin: 3% auto;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 900px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #1e293b;
        }

        .close {
            color: #64748b;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .close:hover {
            color: #ef4444;
        }

        .modal-chart-container {
            position: relative;
            height: 500px;
            margin-bottom: 20px;
        }

        .modal-summary {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #3b82f6;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Operations KPI Dashboard</h1>
            <p class="subtitle">Warehouse Performance Metrics</p>
        </header>

        <div class="tab-container">
            <div class="tabs">
                <button class="tab-btn active" onclick="showTab('dashboard')">Dashboard</button>
                <button class="tab-btn" onclick="showTab('analytics')">TTM Analytics</button>
            </div>
        </div>

        <!-- Dashboard Tab -->
        <div id="dashboard-tab" class="tab-content active">
            <div class="upload-section">
            <div class="file-input-wrapper">
                <div class="tooltip">
                    <label for="excelFile" class="upload-btn">üìÅ Load Excel File</label>
                    <span class="tooltiptext">
                        <strong>Excel File Format:</strong><br>
                        <strong>Sheet "Shipments":</strong> Date, TTM, Customer, Boxes Picked, Pallets Picked, ft¬≤<br>
                        <strong>Sheet "Errors":</strong> Date, TTM<br>
                        (Accuracy calculated as: error count / shipment count)
                    </span>
                </div>
                <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="handleFileUpload(event)">
            </div>
            <div class="file-info" id="fileInfo">No file loaded. Using sample data.</div>
        </div>
        
        <div class="filter-section">
            <span class="filter-label">View:</span>
            <div class="period-buttons">
                <button class="period-btn active" onclick="setPeriod('daily')">Daily</button>
                <button class="period-btn" onclick="setPeriod('weekly')">Weekly</button>
                <button class="period-btn" onclick="setPeriod('monthly')">Monthly</button>
            </div>
            <span class="filter-label" style="margin-left: 20px;">Date Range:</span>
            <div class="date-range">
                <input type="date" id="startDate" onchange="updateDashboard()">
                <span>to</span>
                <input type="date" id="endDate" onchange="updateDashboard()">
            </div>
        </div>
        
        <div class="metrics-grid">
            <div class="metric-card blue">
                <div class="metric-label">Total Boxes Picked</div>
                <div class="metric-value" id="totalBoxes">-</div>
                <div class="date-display" id="boxesDateRange"></div>
            </div>
            <div class="metric-card purple">
                <div class="metric-label">Total Pallets</div>
                <div class="metric-value" id="totalPallets">-</div>
                <div class="date-display" id="palletsDateRange"></div>
            </div>
            <div class="metric-card green">
                <div class="metric-label">Total ft¬≤ Shipped</div>
                <div class="metric-value" id="totalSqft">-</div>
                <div class="date-display" id="sqftDateRange"></div>
            </div>
            <div class="metric-card blue">
                <div class="metric-label">Total ft¬≤ Received</div>
                <div class="metric-value" id="totalSqftReceived">-</div>
                <div class="date-display" id="sqftReceivedDateRange"></div>
            </div>
            <div class="metric-card red">
                <div class="metric-label">Error Rate</div>
                <div class="metric-value" id="errorRate">-</div>
                <div class="date-display" id="errorDateRange"></div>
            </div>
            <div class="metric-card blue">
                <div class="metric-label">Avg Accuracy</div>
                <div class="metric-value" id="avgAccuracy">-</div>
                <div class="date-display" id="accuracyDateRange"></div>
            </div>
            <div class="metric-card purple clickable" onclick="openStatisticsModal('TOR', 'sqft')">
                <div class="metric-label">Total ft¬≤ TOR</div>
                <div class="metric-value" id="totalSqftTOR">-</div>
                <div class="date-display">Click for details</div>
            </div>
            <div class="metric-card green clickable" onclick="openStatisticsModal('TOR', 'pallets')">
                <div class="metric-label">Total Pallets TOR</div>
                <div class="metric-value" id="totalPalletsTOR">-</div>
                <div class="date-display">Click for details</div>
            </div>
            <div class="metric-card red clickable" onclick="openStatisticsModal('CAL', 'sqft')">
                <div class="metric-label">Total ft¬≤ CAL</div>
                <div class="metric-value" id="totalSqftCAL">-</div>
                <div class="date-display">Click for details</div>
            </div>
            <div class="metric-card blue clickable" onclick="openStatisticsModal('CAL', 'pallets')">
                <div class="metric-label">Total Pallets CAL</div>
                <div class="metric-value" id="totalPalletsCAL">-</div>
                <div class="date-display">Click for details</div>
            </div>
        </div>
        
        <div class="charts-grid">
            <div class="chart-card">
                <h3 class="chart-title">üì¶ Boxes Picked by Employee</h3>
                <div class="chart-container">
                    <canvas id="boxesChart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">üöö Pallets Picked by Employee</h3>
                <div class="chart-container">
                    <canvas id="palletsChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="chart-card" style="margin-bottom: 30px;">
            <h3 class="chart-title">üìè Square Footage Picked by Employee Over Time</h3>
            <div class="chart-content">
                <div class="ttm-selector">
                    <h4>Select TTMs</h4>
                    <div class="select-all-container">
                        <button class="select-all-btn" onclick="selectAllEmployees()">Select All</button>
                        <button class="deselect-all-btn" onclick="deselectAllEmployees()">Deselect All</button>
                    </div>
                    <div id="employeeCheckboxes"></div>
                </div>
                <div class="chart-container" style="height: 600px;">
                    <canvas id="sqftTrendChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="charts-grid">
            <div class="chart-card">
                <h3 class="chart-title">üìà Productivity Trend Over Time</h3>
                <div class="chart-container">
                    <canvas id="trendChart"></canvas>
                </div>
            </div>
            <div class="chart-card">
                <h3 class="chart-title">‚ö†Ô∏è Errors by Employee</h3>
                <div class="chart-container">
                    <canvas id="errorsChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="chart-card" style="margin-bottom: 30px;">
            <h3 class="chart-title">üìÖ Average Ft¬≤ Picked by Weekday (Click for Customer Breakdown)</h3>
            <div class="chart-container clickable">
                <canvas id="weekdayChart"></canvas>
            </div>
        </div>
        
        <div class="table-card">
            <h3 class="chart-title">Employee Performance Details</h3>
            <table id="dataTable">
                <thead>
                    <tr>
                        <th class="sortable" onclick="sortTable('name')">Employee <span class="sort-indicator">‚ñ≤</span></th>
                        <th class="sortable" onclick="sortTable('boxes')">Boxes <span class="sort-indicator"></span></th>
                        <th class="sortable" onclick="sortTable('pallets')">Pallets <span class="sort-indicator"></span></th>
                        <th class="sortable" onclick="sortTable('errors')">Errors <span class="sort-indicator"></span></th>
                        <th class="sortable" onclick="sortTable('sqft')">Sq Ft Shipped <span class="sort-indicator"></span></th>
                        <th class="sortable" onclick="sortTable('accuracy')">Accuracy <span class="sort-indicator"></span></th>
                        <th class="sortable" onclick="sortTable('linesShipped')">Lines Shipped <span class="sort-indicator"></span></th>
                        <th class="sortable" onclick="sortTable('palletsReceived')"># Pallets Rcvd <span class="sort-indicator"></span></th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>

        </div>

        <!-- Analytics Tab -->
        <div id="analytics-tab" class="tab-content">
            <div class="upload-section">
                <div class="file-input-wrapper">
                    <div class="tooltip">
                        <label for="excelFile" class="upload-btn">üìÅ Load Excel File</label>
                        <span class="tooltiptext">
                            <strong>Excel File Format:</strong><br>
                            <strong>Sheet "Shipments":</strong> Date, TTM, Customer, Boxes Picked, Pallets Picked, ft¬≤<br>
                            <strong>Sheet "Errors":</strong> Date, TTM<br>
                            (Accuracy calculated as: error count / shipment count)
                        </span>
                    </div>
                </div>
                <div class="file-info" id="fileInfo2">No file loaded. Using sample data.</div>
            </div>

            <div class="filter-section">
                <span class="filter-label">Date Range:</span>
                <div class="date-range">
                    <input type="date" id="startDate2" onchange="updateAnalytics()">
                    <span>to</span>
                    <input type="date" id="endDate2" onchange="updateAnalytics()">
                </div>
            </div>

            <div class="chart-card">
                <h3 class="chart-title">TTM ft¬≤ Picked vs Median (Excluding values below 2,000 ft¬≤)</h3>
                <div class="chart-content">
                    <div class="ttm-selector">
                        <h4>Select TTMs</h4>
                        <div class="select-all-container">
                            <button class="select-all-btn" onclick="selectAllTTMs()">Select All</button>
                            <button class="deselect-all-btn" onclick="deselectAllTTMs()">Deselect All</button>
                        </div>
                        <div id="ttmCheckboxes"></div>
                    </div>
                    <div class="chart-container" style="height: 600px;">
                        <canvas id="ttmChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            ¬© 2025 Justin A.F.D. Kozak
        </footer>
    </div>

    <!-- Customer Breakdown Modal -->
    <div id="customerModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Customer Breakdown</h3>
                <span class="close" onclick="closeModal()">&times;</span>
            </div>
            <div class="modal-chart-container">
                <canvas id="customerPieChart"></canvas>
            </div>
            <div class="modal-summary" id="modalSummary">
                <!-- Summary will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Statistics Breakdown Modal -->
    <div id="statisticsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="statsModalTitle">Statistics Breakdown</h3>
                <span class="close" onclick="closeStatisticsModal()">&times;</span>
            </div>
            <div class="table-card" style="padding: 0; box-shadow: none;">
                <table id="statsTable">
                    <thead>
                        <tr id="statsTableHeader">
                            <!-- Headers will be populated dynamically -->
                        </tr>
                    </thead>
                    <tbody id="statsTableBody">
                        <!-- Data will be populated dynamically -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <script>
        /* ========================================
           GLOBAL STATE VARIABLES
           ======================================== */
        
        // Chart.js instances stored by chart name for updating/destroying
        let charts = {};
        
        // Main data arrays loaded from Excel or localStorage
        let allData = [];           // Shipments data (Date, TTM, Customer, Boxes, Pallets, ft¬≤)
        let allErrors = [];         // Errors data (Date, TTM)
        let allReceived = [];       // Receiving data (Date, Receiver, Pallets, ft¬≤)
        let allStatistics = [];     // Statistics data (Item No., Quantities by location, Pallet counts)
        let allPickers = [];        // List of TTM names designated as pickers (pre-selects them in charts)
        
        // TTM Analytics tab chart instance
        let ttmChart = null;
        
        // Selected TTM names for TTM Analytics chart (Set for unique values)
        let selectedTTMs = new Set();
        
        // Selected employee names for Dashboard employee trend chart (Set for unique values)
        let selectedEmployees = new Set();
        
        // Current aggregation period: 'daily', 'weekly', or 'monthly'
        // Change default to 'weekly' or 'monthly' to start with different aggregation
        let currentPeriod = 'daily';
        
        // Chart.js instance for customer breakdown modal pie chart
        let customerModalChart = null;
        
        // Current table sort state (column name and direction)
        // Determines which column is sorted and whether ascending or descending
        let currentSort = { column: 'name', direction: 'asc' };
        
        /* ========================================
           SAMPLE DATA GENERATION (FOR DEMO MODE)
           ======================================== */
        
        /**
         * Generates sample shipment data for demo/testing purposes
         * Used when no Excel file is loaded
         * @returns {Array} Array of sample shipment records
         */
        function generateSampleData() {
            const employees = ['John M.', 'Sarah K.', 'Mike R.', 'Lisa P.', 'David L.', 'Emma W.'];
            const customers = ['Acme Corp', 'Tech Solutions Inc', 'Global Industries', 'MegaMart', 'Supply Chain Co', 'Retail Giant', 'Manufacturing Ltd', 'Distribution Pro', 'Logistics Plus', 'Warehouse Direct', 'Quick Ship', 'Fast Track'];
            const data = [];
            const today = new Date();
            
            // Generate 30 days of data
            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                
                employees.forEach(emp => {
                    // Each employee has multiple shipment lines per day
                    const numShipments = Math.floor(Math.random() * 3) + 2; // 2-4 shipments per day
                    for (let j = 0; j < numShipments; j++) {
                        data.push({
                            date: date.toISOString().split('T')[0],
                            name: emp,
                            customer: customers[Math.floor(Math.random() * customers.length)],
                            boxes: Math.floor(Math.random() * 50) + 50,
                            pallets: Math.floor(Math.random() * 5) + 3,
                            sqft: Math.floor(Math.random() * 500) + 500
                        });
                    }
                });
            }
            return data;
        }
        
        function generateSampleErrors() {
            const employees = ['John M.', 'Sarah K.', 'Mike R.', 'Lisa P.', 'David L.', 'Emma W.'];
            const errors = [];
            const today = new Date();
            
            // Generate 30 days of errors (roughly 2-5% error rate)
            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                
                employees.forEach(emp => {
                    // Random number of errors per day (0-2)
                    const numErrors = Math.random() < 0.7 ? Math.floor(Math.random() * 2) : Math.floor(Math.random() * 3);
                    for (let j = 0; j < numErrors; j++) {
                        errors.push({
                            date: date.toISOString().split('T')[0],
                            name: emp
                        });
                    }
                });
            }
            return errors;
        }
        
        /* ========================================
           DATA PERSISTENCE (localStorage)
           ======================================== */
        
        /**
         * Attempts to load previously cached data from browser's localStorage
         * This allows data to persist between page refreshes without re-uploading Excel file
         * 
         * @returns {boolean} true if data was successfully loaded, false otherwise
         * 
         * Note: localStorage has a size limit (typically 5-10MB). For very large datasets,
         * consider using IndexedDB instead by replacing localStorage.getItem/setItem
         */
        function loadDataFromStorage() {
            try {
                // Retrieve all data from localStorage
                const storedShipments = localStorage.getItem('shippingData');
                const storedErrors = localStorage.getItem('errorData');
                const storedReceived = localStorage.getItem('receivedData');
                const storedStatistics = localStorage.getItem('statisticsData');
                const storedPickers = localStorage.getItem('pickersData');
                const fileName = localStorage.getItem('dataFileName');
                const loadTime = localStorage.getItem('dataLoadedTime');
                
                // Only proceed if core data exists (shipments, errors, received are required)
                if (storedShipments && storedErrors && storedReceived) {
                    // Parse JSON strings back to JavaScript objects/arrays
                    allData = JSON.parse(storedShipments);
                    allErrors = JSON.parse(storedErrors);
                    allReceived = JSON.parse(storedReceived);
                    // Statistics and pickers are optional, default to empty arrays
                    allStatistics = storedStatistics ? JSON.parse(storedStatistics) : [];
                    allPickers = storedPickers ? JSON.parse(storedPickers) : [];
                    
                if (fileName && loadTime) {
                    const timeLoaded = new Date(loadTime).toLocaleString();
                    document.getElementById('fileInfo').textContent = `‚úì Using cached data: ${fileName} (loaded ${timeLoaded})`;
                    document.getElementById('fileInfo2').textContent = `‚úì Using cached data: ${fileName} (loaded ${timeLoaded})`;
                } else {
                    document.getElementById('fileInfo').textContent = `‚úì Using cached data - ${allData.length} shipment records`;
                    document.getElementById('fileInfo2').textContent = `‚úì Using cached data - ${allData.length} shipment records`;
                }                    console.log('Loaded data from localStorage:', allData.length, 'shipments,', allErrors.length, 'errors,', allReceived.length, 'received,', allStatistics.length, 'statistics,', allPickers.length, 'pickers');
                    updateStatisticsMetrics();
                    return true;
                }
            } catch (e) {
                console.warn('Could not load data from localStorage:', e);
            }
            return false;
        }
        
        // Load from storage or use sample data
        if (!loadDataFromStorage()) {
            allData = generateSampleData();
            allErrors = generateSampleErrors();
            allReceived = []; // No sample received data
        }
        
        /* ========================================
           EXCEL FILE UPLOAD & PARSING
           ======================================== */
        
        /**
         * Handles Excel file upload and parsing
         * Reads Excel file, validates required sheets, parses data, and updates dashboard
         * 
         * Required Excel sheets:
         * - Shipments: Date, TTM, Customer, Boxes Picked, Pallets Picked, ft¬≤
         * - Errors: Date, TTM
         * - Received: Date, Receiver, Pallets, ft¬≤
         * - Statistics: Item No., Quantity TOR/QUATOR/CLAIMSTOR/CAL/QUACAL/CLAIMSCAL, Pallet Count TOR/CAL
         * - Pickers: TTM (list of picker names for pre-selection in charts)
         * 
         * @param {Event} event - File input change event
         */
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            // Update UI to show loading state
            document.getElementById('fileInfo').textContent = `Loading ${file.name}...`;
            document.getElementById('fileInfo2').textContent = `Loading ${file.name}...`;
            
            // FileReader API to read file as binary
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // Convert to Uint8Array for XLSX library
                    const data = new Uint8Array(e.target.result);
                    // Parse Excel workbook
                    const workbook = XLSX.read(data, { type: 'array' });
                    
                    // Debug: Log available sheet names for troubleshooting
                    console.log('Available sheets:', workbook.SheetNames);
                    
                    /* ========================================
                       SHEET VALIDATION
                       Ensure all required sheets exist in workbook
                       ======================================== */
                    
                    // Validate "Shipments" sheet exists
                    const shipmentsSheet = workbook.Sheets['Shipments'];
                    if (!shipmentsSheet) {
                        throw new Error('Sheet "Shipments" not found. Please ensure your Excel file has a sheet named "Shipments". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    // Look for the "Errors" sheet
                    const errorsSheet = workbook.Sheets['Errors'];
                    if (!errorsSheet) {
                        throw new Error('Sheet "Errors" not found. Please ensure your Excel file has a sheet named "Errors". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    // Look for the "Received" sheet
                    const receivedSheet = workbook.Sheets['Received'];
                    if (!receivedSheet) {
                        throw new Error('Sheet "Received" not found. Please ensure your Excel file has a sheet named "Received". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    // Look for the "Statistics" sheet
                    const statisticsSheet = workbook.Sheets['Statistics'];
                    if (!statisticsSheet) {
                        throw new Error('Sheet "Statistics" not found. Please ensure your Excel file has a sheet named "Statistics". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    // Look for the "Pickers" sheet
                    const pickersSheet = workbook.Sheets['Pickers'];
                    if (!pickersSheet) {
                        throw new Error('Sheet "Pickers" not found. Please ensure your Excel file has a sheet named "Pickers". Available sheets: ' + workbook.SheetNames.join(', '));
                    }
                    
                    const jsonData = XLSX.utils.sheet_to_json(shipmentsSheet, {range: 1});// Start parsing from the second row (index 1)
                    const errorsData = XLSX.utils.sheet_to_json(errorsSheet, {range: 1});
                    const receivedData = XLSX.utils.sheet_to_json(receivedSheet, {range: 2}); // Skip extra header row
                    const statisticsData = XLSX.utils.sheet_to_json(statisticsSheet, {range: 1});
                    const pickersData = XLSX.utils.sheet_to_json(pickersSheet, {range: 1});
                    
                    console.log('Raw Shipments data count:', jsonData.length);
                    console.log('Sample row from Excel:', jsonData[0]);
                    console.log('Column names detected:', Object.keys(jsonData[0] || {}));
                    console.log('Raw Errors data count:', errorsData.length);
                    console.log('Sample error row:', errorsData[0]);
                    console.log('Raw Received data count:', receivedData.length);
                    console.log('Sample received row:', receivedData[0]);
                    console.log('Second received row:', receivedData[1]);
                    console.log('Third received row:', receivedData[2]);
                    console.log('Raw Statistics data count:', statisticsData.length);
                    console.log('Sample statistics row:', statisticsData[0]);
                    console.log('Raw Pickers data count:', pickersData.length);
                    console.log('Sample pickers row:', pickersData[0]);
                    
                    allData = jsonData.map(row => {
                        let dateValue = row['Date'] || row['date'] || row['DATE'];
                        
                        // Handle Excel date serial numbers
                        if (typeof dateValue === 'number') {
                            const excelEpoch = new Date(1899, 11, 30);
                            const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                            dateValue = date.toISOString().split('T')[0];
                        } else if (dateValue instanceof Date) {
                            dateValue = dateValue.toISOString().split('T')[0];
                        } else if (typeof dateValue === 'string') {
                            // Try to parse string dates
                            const parsed = new Date(dateValue);
                            if (!isNaN(parsed.getTime())) {
                                dateValue = parsed.toISOString().split('T')[0];
                            }
                        }
                        
                        return {
                            date: dateValue,
                            name: row['TTM'] || row['Employee'] || row['Name'] || row['employee'] || row['name'] || 'Unknown',
                            customer: row['Customer'] || row['customer'] || row['CUSTOMER'] || 'Unknown',
                            boxes: parseInt(row['Boxes Picked'] || row['boxes'] || row['BOXES'] || 0),
                            pallets: parseInt(row['Pallets Picked'] || row['pallets'] || row['PALLETS'] || 0),
                            sqft: parseInt(row['ft¬≤'] || row['sqft'] || row['Square Footage'] || row['SQFT'] || row['Sq Ft'] || 0)
                        };
                    });
                    
                    // Process errors data
                    console.log('Processing errors - before mapping:', errorsData.length, 'rows');
                    if (errorsData.length > 0) {
                        console.log('First error row (raw):', errorsData[0]);
                        console.log('Error columns:', Object.keys(errorsData[0]));
                    }
                    
                    const mappedErrors = errorsData.map((row, index) => {
                        // Try multiple possible date column names
                        let dateValue = row['Shipment Date'] || row['Date'] || row['date'] || row['DATE'] || 
                                       row['Date of Error'] || row['Error Date'] ||
                                       row['__EMPTY'] || row['__EMPTY_2'] || row['__EMPTY_3'];
                        
                        // If still no date, try to find any column that looks like a date
                        if (!dateValue) {
                            const keys = Object.keys(row);
                            for (let key of keys) {
                                if (key !== '__EMPTY_1' && row[key]) {
                                    // Check if it's a number (Excel serial date) or looks like a date
                                    if (typeof row[key] === 'number' || 
                                        (typeof row[key] === 'string' && row[key].match(/\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/))) {
                                        dateValue = row[key];
                                        if (index === 0) {
                                            console.log(`Using column "${key}" as date column`);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        
                        // Handle Excel date serial numbers
                        if (typeof dateValue === 'number') {
                            const excelEpoch = new Date(1899, 11, 30);
                            const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                            dateValue = date.toISOString().split('T')[0];
                        } else if (dateValue instanceof Date) {
                            dateValue = dateValue.toISOString().split('T')[0];
                        } else if (typeof dateValue === 'string') {
                            // Handle MM/DD/YYYY format specifically
                            const mmddyyyyMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                            if (mmddyyyyMatch) {
                                const [, month, day, year] = mmddyyyyMatch;
                                dateValue = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                            } else {
                                // Try standard date parsing
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    dateValue = parsed.toISOString().split('T')[0];
                                }
                            }
                        }
                        
                        // Try multiple possible TTM column names
                        const ttmName = row['TTM'] || row['ttm'] || row['Employee'] || row['employee'] || 
                                       row['Name'] || row['name'] || row['Team Member'] || 
                                       row['__EMPTY_1'] || 'Unknown';
                        
                        if (index === 0) {
                            console.log('First error row processing:');
                            console.log('  Raw row:', row);
                            console.log('  Date value found:', dateValue);
                            console.log('  TTM name found:', ttmName);
                        }
                        
                        return {
                            date: dateValue,
                            name: ttmName
                        };
                    });
                    
                    console.log('Mapped errors before filter:', mappedErrors.length);
                    if (mappedErrors.length > 0) {
                        console.log('First mapped error:', mappedErrors[0]);
                    }
                    
                    // Filter out "ignore" rows AND rows with invalid dates (like header rows)
                    allErrors = mappedErrors.filter(row => {
                        const nameValid = row.name && row.name.toLowerCase() !== 'ignore';
                        const dateValid = row.date && row.date !== 'undefined' && 
                                         !row.date.toLowerCase().includes('auto') &&
                                         !row.date.toLowerCase().includes('date') &&
                                         row.date.match(/\d{4}-\d{2}-\d{2}/); // Must be in YYYY-MM-DD format
                        
                        return nameValid && dateValid;
                    });
                    
                    console.log('After filtering "ignore" and invalid dates:', allErrors.length);
                    if (allErrors.length > 0) {
                        console.log('First error after filter:', allErrors[0]);
                        console.log('Last error after filter:', allErrors[allErrors.length - 1]);
                    } else {
                        console.warn('WARNING: All error rows were filtered out or no errors exist!');
                        console.log('Check if all TTM names are "ignore" or if the TTM column name is incorrect');
                        console.log('Mapped errors before filtering:', mappedErrors.slice(0, 5));
                    }
                    
                    console.log('Processed data sample:', allData[0]);
                    console.log('Total shipment records:', allData.length);
                    console.log('Total error records:', allErrors.length);
                    
                    // Process received data
                    console.log('Processing received data - before mapping:', receivedData.length, 'rows');
                    if (receivedData.length > 0) {
                        console.log('First received row (raw):', receivedData[0]);
                        console.log('Received columns:', Object.keys(receivedData[0]));
                    }
                    
                    const mappedReceived = receivedData.map((row, index) => {
                        let dateValue = row['__EMPTY_8'] || row['Receive Date'] || row['receive date'] || row['Date'] || row['date'] || row['DATE'];
                        
                        // Handle Excel date serial numbers
                        if (typeof dateValue === 'number') {
                            const excelEpoch = new Date(1899, 11, 30);
                            const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                            dateValue = date.toISOString().split('T')[0];
                        } else if (dateValue instanceof Date) {
                            dateValue = dateValue.toISOString().split('T')[0];
                        } else if (typeof dateValue === 'string') {
                            // Handle MM/DD/YYYY format specifically
                            const mmddyyyyMatch = dateValue.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                            if (mmddyyyyMatch) {
                                const [, month, day, year] = mmddyyyyMatch;
                                dateValue = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
                            } else {
                                // Try standard date parsing
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    dateValue = parsed.toISOString().split('T')[0];
                                }
                            }
                        }
                        
                        const sqftValue = row['__EMPTY_6'] || row['ft¬≤'] || row['sqft'] || row['Square Footage'] || row['SQFT'] || row['Sq Ft'];
                        const sqftParsed = parseFloat(sqftValue) || 0;
                        
                        const receiverName = row['__EMPTY_9'] || row['Receiver'] || row['receiver'] || row['TTM'] || 'Unknown';
                        const palletCount = parseFloat(row['__EMPTY_11'] || row['Pallet Count'] || row['pallet count'] || row['Pallets'] || 0) || 0;
                        
                        if (index < 3) {
                            console.log(`Received row ${index}:`, {
                                rawDate: row['__EMPTY_8'] || row['Receive Date'] || row['Date'],
                                parsedDate: dateValue,
                                rawSqft: sqftValue,
                                parsedSqft: sqftParsed,
                                receiver: receiverName,
                                palletCount: palletCount,
                                allKeys: Object.keys(row)
                            });
                        }
                        
                        return {
                            date: dateValue,
                            sqft: sqftParsed,
                            receiver: receiverName,
                            pallets: palletCount
                        };
                    });
                    
                    console.log('Mapped received before filter:', mappedReceived.length);
                    
                    allReceived = mappedReceived.filter(row => {
                        const dateValid = row.date && row.date !== 'undefined' && 
                                         row.date.match(/\d{4}-\d{2}-\d{2}/); // Must be in YYYY-MM-DD format
                        return dateValid;
                    });
                    
                    console.log('Total received records:', allReceived.length);
                    if (allReceived.length > 0) {
                        console.log('First received after processing:', allReceived[0]);
                    }
                    
                    // Process statistics data - just store as is, no date filtering needed
                    allStatistics = statisticsData.map(row => ({
                        itemNo: row['Item No.'] || row['item no.'] || row['ITEM NO.'] || 'Unknown',
                        quantityTOR: parseFloat(row['Quantity TOR'] || row['quantity tor'] || 0) || 0,
                        quantityQUATOR: parseFloat(row['Quantity QUATOR'] || row['quantity quator'] || 0) || 0,
                        quantityCLAIMSTOR: parseFloat(row['Quantity CLAIMSTOR'] || row['quantity claimstor'] || 0) || 0,
                        quantityCAL: parseFloat(row['Quantity CAL'] || row['quantity cal'] || 0) || 0,
                        quantityQUACAL: parseFloat(row['Quantity QUACAL'] || row['quantity quacal'] || 0) || 0,
                        quantityCLAIMSCAL: parseFloat(row['Quantity CLAIMSCAL'] || row['quantity claimscal'] || 0) || 0,
                        palletCountTOR: parseFloat(row['Pallet Count TOR'] || row['pallet count tor'] || 0) || 0,
                        palletCountCAL: parseFloat(row['Pallet Count CAL'] || row['pallet count cal'] || 0) || 0
                    }));
                    
                    console.log('Total statistics records:', allStatistics.length);
                    if (allStatistics.length > 0) {
                        console.log('First statistics after processing:', allStatistics[0]);
                    }
                    
                    // Process Pickers data
                    allPickers = pickersData.map(row => row['TTM'] || row['ttm'] || row['Name'] || row['name']).filter(name => name);
                    
                    console.log('Total pickers:', allPickers.length);
                    console.log('Picker names:', allPickers);
                    
                    // Set date range based on data
                    const dates = allData.map(d => d.date).filter(d => d).sort();
                    if (dates.length > 0) {
                        document.getElementById('startDate').value = dates[0];
                        document.getElementById('endDate').value = dates[dates.length - 1];
                        document.getElementById('startDate2').value = dates[0];
                        document.getElementById('endDate2').value = dates[dates.length - 1];
                    } else {
                        // If no valid dates, clear the date filters
                        document.getElementById('startDate').value = '';
                        document.getElementById('endDate').value = '';
                        document.getElementById('startDate2').value = '';
                        document.getElementById('endDate2').value = '';
                    }
                    
                    // Store data in localStorage to share with other pages
                    try {
                        localStorage.setItem('shippingData', JSON.stringify(allData));
                        localStorage.setItem('errorData', JSON.stringify(allErrors));
                        localStorage.setItem('receivedData', JSON.stringify(allReceived));
                        localStorage.setItem('statisticsData', JSON.stringify(allStatistics));
                        localStorage.setItem('pickersData', JSON.stringify(allPickers));
                        localStorage.setItem('dataLoadedTime', new Date().toISOString());
                        localStorage.setItem('dataFileName', file.name);
                    } catch (e) {
                        console.warn('Could not save data to localStorage:', e);
                    }
                    
                    // Reset selections for new data load
                    selectedEmployees.clear();
                    selectedTTMs.clear();
                    document.getElementById('employeeCheckboxes').innerHTML = '';
                    document.getElementById('ttmCheckboxes').innerHTML = '';
                    
                    document.getElementById('fileInfo').textContent = `‚úì Loaded ${file.name} - ${allData.length} shipment records, ${allErrors.length} error records, ${allReceived.length} received records, ${allStatistics.length} statistics records, ${allPickers.length} pickers`;
                    document.getElementById('fileInfo2').textContent = `‚úì Loaded ${file.name} - ${allData.length} shipment records, ${allErrors.length} error records, ${allReceived.length} received records, ${allStatistics.length} statistics records, ${allPickers.length} pickers`;
                    updateDashboard();
                    updateStatisticsMetrics();
                } catch (error) {
                    const errorMsg = `‚ùå Error: ${error.message}`;
                    document.getElementById('fileInfo').textContent = errorMsg;
                    document.getElementById('fileInfo2').textContent = errorMsg;
                    console.error('Full error:', error);
                    console.error('Error stack:', error.stack);
                    alert('Error loading file: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function setPeriod(period) {
            currentPeriod = period;
            document.querySelectorAll('.period-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            updateDashboard();
        }
        
        /* ========================================
           DATE FILTERING FUNCTIONS
           ======================================== */
        
        /**
         * Filters shipment data by date range
         * Automatically uses appropriate date inputs based on active tab
         * 
         * @returns {Array} Filtered shipment data
         * 
         * Date input behavior:
         * - Dashboard tab: Uses startDate and endDate
         * - Analytics tab: Uses startDate2 and endDate2
         * - No dates set: Returns all data (unfiltered)
         * 
         * Date comparison: Uses string comparison (YYYY-MM-DD format)
         * This works correctly because ISO date format is lexicographically sortable
         * 
         * To add additional filters (e.g., by customer or employee):
         * Add filter conditions after date filtering, e.g.:
         * filtered = filtered.filter(d => d.customer === selectedCustomer);
         */
        function getFilteredData() {
            // Get date values from both tab's date inputs
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            const startDate2 = document.getElementById('startDate2').value;
            const endDate2 = document.getElementById('endDate2').value;
            
            // Determine which date inputs to use based on active tab
            const activeTab = document.querySelector('.tab-content.active');
            const useAnalyticsDates = activeTab && activeTab.id === 'analytics-tab';
            
            const actualStartDate = useAnalyticsDates ? startDate2 : startDate;
            const actualEndDate = useAnalyticsDates ? endDate2 : endDate;
            
            console.log('Date range - Start:', actualStartDate, 'End:', actualEndDate);
            console.log('All data length:', allData.length);
            
            // No filtering if no dates specified
            if (!actualStartDate && !actualEndDate) {
                console.log('No date filters - returning all data');
                return allData;
            }
            
            let filtered = allData;
            
            // Apply start date filter (inclusive)
            if (actualStartDate) {
                filtered = filtered.filter(d => d.date && d.date >= actualStartDate);
            }
            // Apply end date filter (inclusive)
            if (actualEndDate) {
                filtered = filtered.filter(d => d.date && d.date <= actualEndDate);
            }
            
            console.log('After filtering:', filtered.length, 'records');
            
            return filtered;
        }
        
        /**
         * Filters error data by date range (Dashboard tab dates only)
         * 
         * @returns {Array} Filtered error data
         * 
         * Note: Errors use Dashboard tab dates, not Analytics tab dates
         * Errors are only displayed on the Dashboard tab
         */
        function getFilteredErrors() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // No filtering if no dates specified
            if (!startDate && !endDate) {
                return allErrors;
            }
            
            let filtered = allErrors;
            
            // Apply date filters (inclusive on both ends)
            if (startDate) {
                filtered = filtered.filter(d => d.date && d.date >= startDate);
            }
            if (endDate) {
                filtered = filtered.filter(d => d.date && d.date <= endDate);
            }
            
            return filtered;
        }
        
        /**
         * Filters receiving data by date range (Dashboard tab dates only)
         * 
         * @returns {Array} Filtered receiving data
         * 
         * Receiving data is used for:
         * - "Total ft¬≤ Received" metric tile
         * - Background shading on employee trend charts
         * - "# Pallets Rcvd" column in performance table
         */
        function getFilteredReceived() {
            const startDate = document.getElementById('startDate').value;
            const endDate = document.getElementById('endDate').value;
            
            // No filtering if no dates specified
            if (!startDate && !endDate) {
                return allReceived;
            }
            
            let filtered = allReceived;
            
            // Apply date filters (inclusive on both ends)
            if (startDate) {
                filtered = filtered.filter(d => d.date && d.date >= startDate);
            }
            if (endDate) {
                filtered = filtered.filter(d => d.date && d.date <= endDate);
            }
            
            return filtered;
        }
        
        function calculateErrorsAndAccuracy(filteredShipments, filteredErrors) {
            console.log('=== calculateErrorsAndAccuracy ===');
            console.log('Filtered shipments:', filteredShipments.length);
            console.log('Filtered errors:', filteredErrors.length);
            
            // Count errors by TTM
            const errorsByTTM = {};
            filteredErrors.forEach(error => {
                if (!errorsByTTM[error.name]) {
                    errorsByTTM[error.name] = 0;
                }
                errorsByTTM[error.name]++;
            });
            
            // Count shipment lines by TTM
            const shipmentsByTTM = {};
            filteredShipments.forEach(shipment => {
                if (!shipmentsByTTM[shipment.name]) {
                    shipmentsByTTM[shipment.name] = 0;
                }
                shipmentsByTTM[shipment.name]++;
            });
            
            // Calculate accuracy for each TTM (error rate as percentage)
            const accuracyByTTM = {};
            Object.keys(shipmentsByTTM).forEach(name => {
                const errorCount = errorsByTTM[name] || 0;
                const shipmentCount = shipmentsByTTM[name] || 1;
                // Error rate as percentage: (errors / shipments) * 100
                const errorRate = (errorCount / shipmentCount) * 100;
                accuracyByTTM[name] = errorRate.toFixed(2);
            });
            
            console.log('Errors by TTM:', errorsByTTM);
            console.log('Shipments by TTM:', shipmentsByTTM);
            console.log('Accuracy by TTM:', accuracyByTTM);
            
            return {
                errorsByTTM,
                shipmentsByTTM,
                accuracyByTTM
            };
        }
        
        /* ========================================
           DATA AGGREGATION BY TIME PERIOD
           ======================================== */
        
        /**
         * Aggregates shipment data by selected time period (daily/weekly/monthly)
         * Combines data by employee and calculates totals
         * 
         * @param {Array} data - Filtered shipment data
         * @param {Object} errorStats - Error counts and accuracy rates by TTM
         * @param {Array} receivedData - Filtered receiving data for pallets received calculation
         * @returns {Array} Aggregated employee data with totals
         * 
         * Aggregation keys:
         * - Daily: employee-date (e.g., "John M.-2025-10-15")
         * - Weekly: employee-week start date (Sunday)
         * - Monthly: employee-year-month (e.g., "John M.-2025-10")
         * 
         * To add a new aggregation period (e.g., quarterly):
         * 1. Add new currentPeriod value check
         * 2. Calculate quarter: Math.floor(date.getMonth() / 3) + 1
         * 3. Create key: `${row.name}-${date.getFullYear()}-Q${quarter}`
         * 4. Add period button in HTML
         */
        function aggregateByPeriod(data, errorStats, receivedData) {
            const grouped = {};
            
            // First pass: Group data by employee and period
            data.forEach(row => {
                let key;
                const date = new Date(row.date);
                
                // Generate grouping key based on selected period
                if (currentPeriod === 'daily') {
                    // One entry per employee per day
                    key = `${row.name}-${row.date}`;
                } else if (currentPeriod === 'weekly') {
                    // Calculate week start (Sunday)
                    const weekStart = new Date(date);
                    weekStart.setDate(date.getDate() - date.getDay());
                    key = `${row.name}-${weekStart.toISOString().split('T')[0]}`;
                } else { // monthly
                    // One entry per employee per month
                    key = `${row.name}-${date.getFullYear()}-${date.getMonth() + 1}`;
                }
                
                // Initialize group if doesn't exist
                if (!grouped[key]) {
                    grouped[key] = {
                        name: row.name,
                        boxes: 0,
                        pallets: 0,
                        sqft: 0,
                        days: 0  // Track number of days in this period
                    };
                }
                
                // Sum up metrics for this group
                grouped[key].boxes += row.boxes;
                grouped[key].pallets += row.pallets;
                grouped[key].sqft += row.sqft;
                grouped[key].days++;
            });
            
            // Aggregate by employee
            const byEmployee = {};
            Object.values(grouped).forEach(item => {
                if (!byEmployee[item.name]) {
                    byEmployee[item.name] = {
                        name: item.name,
                        boxes: 0,
                        pallets: 0,
                        sqft: 0,
                        days: 0,
                        errors: 0,
                        accuracy: 0,
                        linesShipped: 0,
                        palletsReceived: 0
                    };
                }
                byEmployee[item.name].boxes += item.boxes;
                byEmployee[item.name].pallets += item.pallets;
                byEmployee[item.name].sqft += item.sqft;
                byEmployee[item.name].days += item.days;
            });
            
            // Add error counts, accuracy, and shipment counts from errorStats
            Object.keys(byEmployee).forEach(name => {
                byEmployee[name].errors = errorStats.errorsByTTM[name] || 0;
                byEmployee[name].accuracy = parseFloat(errorStats.accuracyByTTM[name]) || 0;
                byEmployee[name].linesShipped = errorStats.shipmentsByTTM[name] || 0;
            });
            
            // Add pallets received from receivedData
            if (receivedData && receivedData.length > 0) {
                receivedData.forEach(row => {
                    if (row.receiver && byEmployee[row.receiver]) {
                        byEmployee[row.receiver].palletsReceived += row.pallets || 0;
                    }
                });
            }
            
            return Object.values(byEmployee);
        }
        
        /* ========================================
           MAIN DASHBOARD UPDATE ORCHESTRATOR
           ======================================== */
        
        /**
         * Main function that updates all dashboard components
         * Called whenever data changes (file upload, date filter, period selection)
         * 
         * Process flow:
         * 1. Filter data by date range
         * 2. Calculate error statistics
         * 3. Aggregate data by selected period (daily/weekly/monthly)
         * 4. Update metric cards, charts, and table
         * 
         * Example: To add a new chart, call your update function here after updateTable()
         */
        function updateDashboard() {
            console.log('=== UPDATE DASHBOARD CALLED ===');
            console.log('allData length:', allData.length);
            console.log('allErrors length:', allErrors.length);
            
            // Apply date filters to get relevant data
            const filteredData = getFilteredData();
            const filteredErrors = getFilteredErrors();
            const filteredReceivedData = getFilteredReceived();
            console.log('Filtered data:', filteredData.length, 'records');
            console.log('Filtered errors:', filteredErrors.length, 'records');
            console.log('Sample filtered record:', filteredData[0]);
            
            // Validation: Ensure we have data to display
            if (filteredData.length === 0) {
                console.warn('WARNING: No filtered data available!');
                alert('No data available after filtering. Check your date range or data file.');
                return;
            }
            
            // Calculate error rates and accuracy by employee
            const errorStats = calculateErrorsAndAccuracy(filteredData, filteredErrors);
            
            // Aggregate shipment data by employee and selected period
            const aggregatedData = aggregateByPeriod(filteredData, errorStats, filteredReceivedData);
            console.log('Aggregated data:', aggregatedData.length, 'employees');
            console.log('Sample aggregated record:', aggregatedData[0]);
            
            // Validation: Ensure aggregation succeeded
            if (aggregatedData.length === 0) {
                console.warn('WARNING: No aggregated data!');
                alert('No aggregated data available. Check console for details.');
                return;
            }
            
            // Update all dashboard components
            updateMetrics(aggregatedData, filteredData);  // Update KPI tiles
            updateCharts(aggregatedData, filteredData);   // Update all charts
            updateTable(aggregatedData);                  // Update performance table
            console.log('=== DASHBOARD UPDATE COMPLETE ===');
        }
        
        /**
         * Updates metric cards (KPI tiles) at top of dashboard
         * Calculates and displays totals for boxes, pallets, sq ft, errors, and accuracy
         * 
         * @param {Array} data - Aggregated employee data with totals
         * @param {Array} rawData - Raw filtered shipment data for additional calculations
         * 
         * To add a new metric tile:
         * 1. Calculate the value here (e.g., const totalCustomers = new Set(rawData.map(r => r.customer)).size)
         * 2. Update the HTML display (e.g., document.getElementById('totalCustomers').textContent = totalCustomers)
         * 3. Add corresponding HTML metric-card in the dashboard
         */
        function updateMetrics(data, rawData) {
            // Sum totals across all employees
            const totalBoxes = data.reduce((sum, emp) => sum + emp.boxes, 0);
            const totalPallets = data.reduce((sum, emp) => sum + emp.pallets, 0);
            const totalErrors = data.reduce((sum, emp) => sum + emp.errors, 0);
            const totalSqft = data.reduce((sum, emp) => sum + emp.sqft, 0);
            const totalLinesShipped = data.reduce((sum, emp) => sum + emp.linesShipped, 0);
            
            // Calculate average error rate, then convert to accuracy rate (100 - error rate)
            const avgErrorRate = data.reduce((sum, emp) => sum + parseFloat(emp.accuracy), 0) / data.length;
            const avgAccuracy = (100 - avgErrorRate).toFixed(2);
            
            // Overall error rate as percentage of lines shipped
            const errorRate = totalLinesShipped > 0 ? ((totalErrors / totalLinesShipped) * 100).toFixed(2) : '0.00';
            
            // Calculate total ft¬≤ received from filtered receiving data
            const filteredReceivedData = getFilteredReceived();
            const totalSqftReceived = filteredReceivedData.reduce((sum, row) => sum + (row.sqft || 0), 0);
            
            // Get date range for display
            const startDate = document.getElementById('startDate').value || 'All';
            const endDate = document.getElementById('endDate').value || 'All';
            const dateRangeText = `${startDate} to ${endDate}`;
            
            // Update DOM elements with formatted numbers
            document.getElementById('totalBoxes').textContent = totalBoxes.toLocaleString();
            document.getElementById('totalPallets').textContent = totalPallets.toLocaleString();
            document.getElementById('totalSqft').textContent = totalSqft.toLocaleString();
            document.getElementById('totalSqftReceived').textContent = Math.round(totalSqftReceived).toLocaleString();
            document.getElementById('errorRate').textContent = errorRate + '%';
            document.getElementById('avgAccuracy').textContent = avgAccuracy + '%';
            
            // Update date range display on all metric cards
            document.querySelectorAll('.date-display').forEach(el => {
                el.textContent = dateRangeText;
            });
        }
        
        /**
         * Updates Statistics metric tiles (Total ft¬≤ TOR/CAL, Total Pallets TOR/CAL)
         * These metrics are NOT date-filtered - they show current totals from Statistics sheet
         * 
         * Calculations:
         * - TOR ft¬≤ = sum of (Quantity TOR + Quantity QUATOR + Quantity CLAIMSTOR)
         * - CAL ft¬≤ = sum of (Quantity CAL + Quantity QUACAL + Quantity CLAIMSCAL)
         * - Pallets = direct sum of Pallet Count columns
         * 
         * To change location names or add new locations:
         * 1. Update the column mappings in Excel sheet parsing
         * 2. Update the calculation logic here
         * 3. Update the modal display logic in openStatisticsModal()
         */
        function updateStatisticsMetrics() {
            // Early return if no statistics data available
            if (!allStatistics || allStatistics.length === 0) {
                return;
            }
            
            // Initialize totals
            let totalSqftTOR = 0;
            let totalSqftCAL = 0;
            let totalPalletsTOR = 0;
            let totalPalletsCAL = 0;
            
            // Sum across all items in statistics sheet
            allStatistics.forEach(item => {
                // TOR total includes three sub-locations
                totalSqftTOR += (item.quantityTOR || 0) + (item.quantityQUATOR || 0) + (item.quantityCLAIMSTOR || 0);
                totalSqftCAL += (item.quantityCAL || 0) + (item.quantityQUACAL || 0) + (item.quantityCLAIMSCAL || 0);
                totalPalletsTOR += (item.palletCountTOR || 0);
                totalPalletsCAL += (item.palletCountCAL || 0);
            });
            
            // Update DOM elements
            const sqftTORElement = document.getElementById('totalSqftTOR');
            const palletsTORElement = document.getElementById('totalPalletsTOR');
            const sqftCALElement = document.getElementById('totalSqftCAL');
            const palletsCALElement = document.getElementById('totalPalletsCAL');
            
            if (sqftTORElement) sqftTORElement.textContent = Math.round(totalSqftTOR).toLocaleString();
            if (palletsTORElement) palletsTORElement.textContent = Math.round(totalPalletsTOR).toLocaleString();
            if (sqftCALElement) sqftCALElement.textContent = Math.round(totalSqftCAL).toLocaleString();
            if (palletsCALElement) palletsCALElement.textContent = Math.round(totalPalletsCAL).toLocaleString();
            
            console.log('Statistics metrics updated - TOR ft¬≤:', Math.round(totalSqftTOR), 'TOR Pallets:', Math.round(totalPalletsTOR), 
                        'CAL ft¬≤:', Math.round(totalSqftCAL), 'CAL Pallets:', Math.round(totalPalletsCAL));
        }
        
        /* ========================================
           STATISTICS MODAL - DRILL-DOWN DISPLAY
           ======================================== */
        
        /**
         * Opens modal showing top 10 items breakdown for a specific region and metric type
         * Triggered when user clicks on Statistics metric tiles
         * 
         * @param {string} region - 'TOR' or 'CAL'
         * @param {string} type - 'sqft' or 'pallets'
         * 
         * For ft¬≤ type: Shows breakdown by 3 sub-locations
         * For pallets type: Shows total pallets only
         * 
         * To change top 10 to top 20:
         * - Change itemsData = itemsData.slice(0, 10) to slice(0, 20)
         * 
         * To add a new region:
         * 1. Add region condition in both if blocks (TOR/CAL)
         * 2. Add corresponding Excel sheet columns
         * 3. Add metric tiles in HTML
         */
        function openStatisticsModal(region, type) {
            // Validate statistics data exists
            if (!allStatistics || allStatistics.length === 0) {
                alert('No statistics data available');
                return;
            }
            
            // Array to store processed item data
            let itemsData = [];
            
            if (type === 'sqft') {
                // Process square footage data with location breakdown
                allStatistics.forEach(item => {
                    let total = 0;
                    let location1 = 0;
                    let location2 = 0;
                    let location3 = 0;
                    
                    // Map region to corresponding quantity columns
                    if (region === 'TOR') {
                        location1 = item.quantityTOR || 0;
                        location2 = item.quantityQUATOR || 0;
                        location3 = item.quantityCLAIMSTOR || 0;
                    } else if (region === 'CAL') {
                        location1 = item.quantityCAL || 0;
                        location2 = item.quantityQUACAL || 0;
                        location3 = item.quantityCLAIMSCAL || 0;
                    }
                    
                    // Calculate total across all sub-locations
                    total = location1 + location2 + location3;
                    
                    // Only include items with non-zero totals
                    if (total > 0) {
                        itemsData.push({
                            itemNo: item.itemNo,
                            total: total,
                            location1: location1,
                            location2: location2,
                            location3: location3
                        });
                    }
                });
                
                // Sort by total (highest first) and limit to top 10
                itemsData.sort((a, b) => b.total - a.total);
                itemsData = itemsData.slice(0, 10);  // Change to slice(0, 20) for top 20
                
                // Build table
                const locationNames = region === 'TOR' ? ['TOR', 'QUATOR', 'CLAIMSTOR'] : ['CAL', 'QUACAL', 'CLAIMSCAL'];
                
                document.getElementById('statsModalTitle').textContent = `Top 10 Items - Total ft¬≤ ${region}`;
                
                const thead = document.querySelector('#statsTable thead tr');
                thead.innerHTML = `
                    <th>Item No.</th>
                    <th>${locationNames[0]}</th>
                    <th>${locationNames[1]}</th>
                    <th>${locationNames[2]}</th>
                    <th>Total</th>
                `;
                
                const tbody = document.querySelector('#statsTable tbody');
                tbody.innerHTML = '';
                
                itemsData.forEach(item => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${item.itemNo}</td>
                        <td>${Math.round(item.location1).toLocaleString()}</td>
                        <td>${Math.round(item.location2).toLocaleString()}</td>
                        <td>${Math.round(item.location3).toLocaleString()}</td>
                        <td><strong>${Math.round(item.total).toLocaleString()}</strong></td>
                    `;
                    tbody.appendChild(row);
                });
                
            } else if (type === 'pallets') {
                // Calculate total pallets per item for the specified region
                allStatistics.forEach(item => {
                    let total = 0;
                    
                    if (region === 'TOR') {
                        total = item.palletCountTOR || 0;
                    } else if (region === 'CAL') {
                        total = item.palletCountCAL || 0;
                    }
                    
                    if (total > 0) {
                        itemsData.push({
                            itemNo: item.itemNo,
                            total: total
                        });
                    }
                });
                
                // Sort by total descending and take top 10
                itemsData.sort((a, b) => b.total - a.total);
                itemsData = itemsData.slice(0, 10);
                
                // Build table
                document.getElementById('statsModalTitle').textContent = `Top 10 Items - Total Pallets ${region}`;
                
                const thead = document.querySelector('#statsTable thead tr');
                thead.innerHTML = `
                    <th>Item No.</th>
                    <th>Total Pallets</th>
                `;
                
                const tbody = document.querySelector('#statsTable tbody');
                tbody.innerHTML = '';
                
                itemsData.forEach(item => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${item.itemNo}</td>
                        <td><strong>${Math.round(item.total).toLocaleString()}</strong></td>
                    `;
                    tbody.appendChild(row);
                });
            }
            
            // Show modal
            document.getElementById('statisticsModal').style.display = 'flex';
        }
        
        function closeStatisticsModal() {
            document.getElementById('statisticsModal').style.display = 'none';
        }
        
        function updateCharts(data, rawData) {
            // Sort data alphabetically by name
            const sortedData = data.sort((a, b) => a.name.localeCompare(b.name));
            const names = sortedData.map(e => e.name);
            const boxes = sortedData.map(e => e.boxes);
            const pallets = sortedData.map(e => e.pallets);
            const errors = sortedData.map(e => e.errors);
            
            // Filter for errors chart - only show TTMs with errors > 0
            const dataWithErrors = sortedData.filter(e => e.errors > 0);
            const namesWithErrors = dataWithErrors.map(e => e.name);
            const errorsFiltered = dataWithErrors.map(e => e.errors);
            
            // Destroy existing charts
            Object.values(charts).forEach(chart => chart.destroy());
            
            // Boxes Chart
            charts.boxes = new Chart(document.getElementById('boxesChart'), {
                type: 'bar',
                data: {
                    labels: names,
                    datasets: [{
                        label: 'Boxes',
                        data: boxes,
                        backgroundColor: '#3b82f6',
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
            
            // Pallets Chart
            charts.pallets = new Chart(document.getElementById('palletsChart'), {
                type: 'bar',
                data: {
                    labels: names,
                    datasets: [{
                        label: 'Pallets',
                        data: pallets,
                        backgroundColor: '#a855f7',
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
            
            // Errors Chart - only show TTMs with errors > 0
            charts.errors = new Chart(document.getElementById('errorsChart'), {
                type: 'bar',
                data: {
                    labels: namesWithErrors,
                    datasets: [{
                        label: 'Errors',
                        data: errorsFiltered,
                        backgroundColor: '#ef4444',
                        borderRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } }
                }
            });
            
            // Trend Chart - aggregate by date
            const trendData = {};
            rawData.forEach(row => {
                if (!trendData[row.date]) {
                    trendData[row.date] = { boxes: 0, pallets: 0, errors: 0 };
                }
                trendData[row.date].boxes += row.boxes;
                trendData[row.date].pallets += row.pallets;
                trendData[row.date].errors += row.errors;
            });
            
            const sortedDates = Object.keys(trendData).sort();
            const trendBoxes = sortedDates.map(d => trendData[d].boxes);
            const trendPallets = sortedDates.map(d => trendData[d].pallets);
            
            charts.trend = new Chart(document.getElementById('trendChart'), {
                type: 'line',
                data: {
                    labels: sortedDates,
                    datasets: [
                        {
                            label: 'Boxes',
                            data: trendBoxes,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            tension: 0.4,
                            fill: true
                        },
                        {
                            label: 'Pallets',
                            data: trendPallets,
                            borderColor: '#a855f7',
                            backgroundColor: 'rgba(168, 85, 247, 0.1)',
                            tension: 0.4,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { display: true, position: 'top' }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });
            
            // Square Footage Trend by Employee - use filtered data
            const filteredData = getFilteredData();
            const sqftByEmployee = {};
            filteredData.forEach(row => {
                if (!sqftByEmployee[row.name]) {
                    sqftByEmployee[row.name] = {};
                }
                if (!sqftByEmployee[row.name][row.date]) {
                    sqftByEmployee[row.name][row.date] = 0;
                }
                sqftByEmployee[row.name][row.date] += row.sqft;
            });
            
            // Get all unique dates from filtered data and sort them
            const allDatesSet = new Set();
            filteredData.forEach(row => allDatesSet.add(row.date));
            const allDates = Array.from(allDatesSet).sort();
            
            // Calculate total shipped per date (sum of all employees)
            const totalShippedPerDate = allDates.map(date => {
                return filteredData
                    .filter(row => row.date === date)
                    .reduce((sum, row) => sum + row.sqft, 0);
            });
            
            // Calculate received per date
            const receivedDataForTrend = getFilteredReceived();
            const receivedPerDate = allDates.map(date => {
                const received = receivedDataForTrend
                    .filter(row => row.date === date)
                    .reduce((sum, row) => sum + row.sqft, 0);
                return received > 0 ? received : null;
            });
            
            // Sort employee names alphabetically
            const sortedEmployeeNames = Object.keys(sqftByEmployee).sort((a, b) => a.localeCompare(b));
            
            // Populate employee checkboxes if not already populated
            populateEmployeeCheckboxes(sortedEmployeeNames);
            
            // Filter to only selected employees
            const selectedEmployeeNames = sortedEmployeeNames.filter(name => selectedEmployees.has(name));
            
            const colors = ['#3b82f6', '#a855f7', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899', '#14b8a6'];
            const sqftDatasets = selectedEmployeeNames.map((empName, idx) => {
                const empData = sqftByEmployee[empName];
                const dataPoints = allDates.map(date => empData[date] || null);
                
                return {
                    label: empName,
                    data: dataPoints,
                    borderColor: colors[idx % colors.length],
                    backgroundColor: colors[idx % colors.length] + '20',
                    tension: 0.4,
                    borderWidth: 2,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    spanGaps: true,
                    type: 'line',
                    order: 1
                };
            });
            
            // Add background datasets for received (dark red) and shipped (dark green)
            sqftDatasets.unshift({
                label: 'Shaded Area: ft¬≤ Received',
                data: receivedPerDate,
                backgroundColor: 'rgba(220, 38, 38, 0.7)', // Dark red with 70% opacity
                borderColor: 'rgba(220, 38, 38, 0.7)',
                type: 'bar',
                order: 3,
                barThickness: 'flex'
            });
            
            sqftDatasets.unshift({
                label: 'Shaded Area: ft¬≤ Shipped',
                data: totalShippedPerDate,
                backgroundColor: 'rgba(22, 163, 74, 0.7)', // Dark green with 70% opacity
                borderColor: 'rgba(22, 163, 74, 0.7)',
                type: 'bar',
                order: 2,
                barThickness: 'flex'
            });
            
            charts.sqftTrend = new Chart(document.getElementById('sqftTrendChart'), {
                type: 'line',
                data: {
                    labels: allDates,
                    datasets: sqftDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true, 
                            position: 'top',
                            labels: {
                                usePointStyle: true,
                                padding: 15
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxTicksLimit: 15
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Square Footage'
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
            
            // Weekday Average Chart - aggregate by unique dates first
            const dailyTotals = {};
            
            // First, sum up all ft¬≤ for each unique date
            filteredData.forEach(row => {
                if (row.date) {
                    if (!dailyTotals[row.date]) {
                        dailyTotals[row.date] = 0;
                    }
                    dailyTotals[row.date] += row.sqft;
                }
            });
            
            // Process received data for weekday chart
            const receivedDataForWeekday = getFilteredReceived();
            const dailyReceived = {};
            receivedDataForWeekday.forEach(row => {
                if (row.date) {
                    if (!dailyReceived[row.date]) {
                        dailyReceived[row.date] = 0;
                    }
                    dailyReceived[row.date] += row.sqft;
                }
            });
            
            // Then group by weekday
            const weekdayData = {
                'Sunday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Monday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Tuesday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Wednesday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Thursday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Friday': { total: 0, count: 0, received: 0, receivedCount: 0 },
                'Saturday': { total: 0, count: 0, received: 0, receivedCount: 0 }
            };
            
            const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            
            Object.keys(dailyTotals).forEach(dateStr => {
                // Parse date manually to avoid timezone issues
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dayName = weekdayNames[date.getDay()];
                weekdayData[dayName].total += dailyTotals[dateStr];
                weekdayData[dayName].count += 1;
            });
            
            Object.keys(dailyReceived).forEach(dateStr => {
                const [year, month, day] = dateStr.split('-').map(Number);
                const date = new Date(year, month - 1, day);
                const dayName = weekdayNames[date.getDay()];
                weekdayData[dayName].received += dailyReceived[dateStr];
                weekdayData[dayName].receivedCount += 1;
            });
            
            const weekdayAverages = weekdayNames.map(day => {
                return weekdayData[day].count > 0 
                    ? Math.round(weekdayData[day].total / weekdayData[day].count)
                    : 0;
            });
            
            const weekdayReceivedAverages = weekdayNames.map(day => {
                return weekdayData[day].receivedCount > 0 
                    ? Math.round(weekdayData[day].received / weekdayData[day].receivedCount)
                    : 0;
            });
            
            charts.weekday = new Chart(document.getElementById('weekdayChart'), {
                type: 'bar',
                data: {
                    labels: weekdayNames,
                    datasets: [
                        {
                            label: 'Shaded Area: ft¬≤ Received',
                            data: weekdayReceivedAverages,
                            backgroundColor: 'rgba(220, 38, 38, 0.7)', // Dark red with 70% opacity
                            borderRadius: 6,
                            order: 2
                        },
                        {
                            label: 'Average Ft¬≤ Picked',
                            data: weekdayAverages,
                            backgroundColor: ['#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#a855f7', '#ec4899', '#8b5cf6'],
                            borderRadius: 6,
                            order: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { 
                        legend: { 
                            display: true,
                            position: 'top'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const day = weekdayNames[context.dataIndex];
                                    const count = weekdayData[day].count;
                                    if (context.datasetIndex === 0) {
                                        return `Avg Received: ${context.parsed.y.toLocaleString()} ft¬≤ (${weekdayData[day].receivedCount} days)`;
                                    } else {
                                        return `Avg Picked: ${context.parsed.y.toLocaleString()} ft¬≤ (${count} days) - Click for customer breakdown`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Average Square Footage'
                            }
                        }
                    },
                    onClick: function(event, elements) {
                        if (elements.length > 0) {
                            const clickedElement = elements[0];
                            const dayName = weekdayNames[clickedElement.index];
                            openModal(dayName);
                        }
                    }
                }
            });
            
        }
        
        /**
         * Handles table column sorting when user clicks on a header
         * Toggles between ascending and descending order
         * Updates visual indicators (arrows) to show current sort state
         * 
         * @param {string} column - Column name to sort by (matches data object property names)
         *                          Valid values: 'name', 'boxes', 'pallets', 'errors', 'sqft', 
         *                          'accuracy', 'linesShipped', 'palletsReceived'
         * 
         * Example: To make errors sort descending by default, check if column === 'errors' 
         * and set currentSort.direction = 'desc'
         */
        function sortTable(column) {
            // Toggle sort direction if clicking the same column again
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                // New column - start with ascending sort
                currentSort.column = column;
                currentSort.direction = 'asc';
            }
            
            // Clear all sort indicators from headers
            document.querySelectorAll('th.sortable').forEach(th => {
                th.classList.remove('active');
                const indicator = th.querySelector('.sort-indicator');
                if (indicator) indicator.textContent = '';
            });
            
            // Set active indicator on currently sorted column
            const activeHeader = document.querySelector(`th.sortable[onclick*="${column}"]`);
            if (activeHeader) {
                activeHeader.classList.add('active');
                const indicator = activeHeader.querySelector('.sort-indicator');
                if (indicator) {
                    // Show up arrow for ascending, down arrow for descending
                    indicator.textContent = currentSort.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                }
            }
            
            // Re-render the table with new sort order
            updateDashboard();
        }
        
        /**
         * Updates the Employee Performance Details table
         * Applies current sort settings and renders rows with color-coded badges
         * 
         * @param {Array} data - Aggregated employee data to display
         * 
         * Badge Color Thresholds (customize these values):
         * - Errors: green (<=2), yellow (3-5), red (>5)
         * - Accuracy: green (>=97%), yellow (95-97%), red (<95%)
         * 
         * To add a new column:
         * 1. Add <th> in HTML table header with onclick="sortTable('newColumn')"
         * 2. Add data calculation in aggregateByPeriod() function
         * 3. Add <td> here in row.innerHTML with ${emp.newColumn}
         */
        function updateTable(data) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';  // Clear existing rows
            
            // Sort data based on current sort settings
            const sortedData = [...data].sort((a, b) => {
                let aVal = a[currentSort.column];
                let bVal = b[currentSort.column];
                
                // Special handling for accuracy (stored internally as error rate)
                // Convert to accuracy percentage for sorting
                if (currentSort.column === 'accuracy') {
                    aVal = 100 - parseFloat(a.accuracy);
                    bVal = 100 - parseFloat(b.accuracy);
                }
                
                // Handle string vs number comparison
                if (typeof aVal === 'string') {
                    // Use localeCompare for case-insensitive alphabetical sorting
                    return currentSort.direction === 'asc' 
                        ? aVal.localeCompare(bVal)
                        : bVal.localeCompare(aVal);
                } else {
                    // Numeric comparison
                    return currentSort.direction === 'asc' 
                        ? aVal - bVal
                        : bVal - aVal;
                }
            });
            
            // Render employee rows
            sortedData.forEach(emp => {
                const row = tbody.insertRow();
                
                // Convert error rate to accuracy rate: 100 - error rate
                const errorRate = parseFloat(emp.accuracy);
                const accuracyRate = 100 - errorRate;
                
                // Determine badge color based on accuracy thresholds
                // Change thresholds: accuracyRate >= 99 for stricter standard
                const accuracyBadge = accuracyRate >= 97 ? 'green' : accuracyRate >= 95 ? 'yellow' : 'red';
                
                // Build row HTML with color-coded badges
                row.innerHTML = `
                    <td><strong>${emp.name}</strong></td>
                    <td>${emp.boxes.toLocaleString()}</td>
                    <td>${emp.pallets}</td>
                    <td><span class="badge ${emp.errors <= 2 ? 'green' : emp.errors <= 5 ? 'yellow' : 'red'}">${emp.errors}</span></td>
                    <td>${emp.sqft.toLocaleString()}</td>
                    <td><span class="badge ${accuracyBadge}">${accuracyRate.toFixed(2)}%</span></td>
                    <td>${emp.linesShipped}</td>
                    <td>${Math.round(emp.palletsReceived || 0)}</td>
                `;
            });
            
            // Add totals row
            const totalBoxes = sortedData.reduce((sum, emp) => sum + emp.boxes, 0);
            const totalPallets = sortedData.reduce((sum, emp) => sum + emp.pallets, 0);
            const totalErrors = sortedData.reduce((sum, emp) => sum + emp.errors, 0);
            const totalSqft = sortedData.reduce((sum, emp) => sum + emp.sqft, 0);
            // Calculate average error rate then convert to accuracy rate
            const avgErrorRate = sortedData.reduce((sum, emp) => sum + parseFloat(emp.accuracy), 0) / sortedData.length;
            const avgAccuracy = (100 - avgErrorRate).toFixed(2);
            const totalLinesShipped = sortedData.reduce((sum, emp) => sum + emp.linesShipped, 0);
            const totalPalletsReceived = sortedData.reduce((sum, emp) => sum + (emp.palletsReceived || 0), 0);
            
            const totalRow = tbody.insertRow();
            totalRow.style.background = '#f1f5f9';
            totalRow.style.fontWeight = 'bold';
            totalRow.innerHTML = `
                <td>TOTAL</td>
                <td>${totalBoxes.toLocaleString()}</td>
                <td>${totalPallets}</td>
                <td>${totalErrors}</td>
                <td>${totalSqft.toLocaleString()}</td>
                <td>${avgAccuracy}%</td>
                <td>${totalLinesShipped}</td>
                <td>${Math.round(totalPalletsReceived)}</td>
            `;
        }
        
        // Modal functions
        function openModal(dayName) {
            const modal = document.getElementById('customerModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalSummary = document.getElementById('modalSummary');
            
            modalTitle.textContent = `Customer Breakdown - ${dayName}`;
            
            // Calculate customer data for the selected day
            const filteredData = getFilteredData();
            const customerData = {};
            const weekdayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const dayIndex = weekdayNames.indexOf(dayName);
            
            filteredData.forEach(row => {
                if (row.customer && row.customer !== 'Unknown' && row.date) {
                    const [year, month, day] = row.date.split('-').map(Number);
                    const date = new Date(year, month - 1, day);
                    if (date.getDay() === dayIndex) {
                        if (!customerData[row.customer]) {
                            customerData[row.customer] = 0;
                        }
                        customerData[row.customer] += row.sqft;
                    }
                }
            });
            
            // Sort customers by volume and get top 14
            const sortedCustomers = Object.keys(customerData)
                .sort((a, b) => customerData[b] - customerData[a]);
            
            const top14Customers = sortedCustomers.slice(0, 14);
            const otherCustomers = sortedCustomers.slice(14);
            
            const totalSqft = Object.values(customerData).reduce((sum, val) => sum + val, 0);
            
            // Calculate "Other" total
            const otherTotal = otherCustomers.reduce((sum, customer) => sum + customerData[customer], 0);
            
            // Create pie chart data
            const pieData = top14Customers.map(customer => ({
                label: customer,
                value: customerData[customer],
                percentage: ((customerData[customer] / totalSqft) * 100).toFixed(1)
            }));
            
            // Add "Other" category if there are additional customers
            if (otherTotal > 0) {
                pieData.push({
                    label: 'Other',
                    value: otherTotal,
                    percentage: ((otherTotal / totalSqft) * 100).toFixed(1)
                });
            }
            
            // Update summary
            const topCustomer = pieData[0];
            const otherCategory = pieData.find(item => item.label === 'Other');
            const individualCustomers = pieData.filter(item => item.label !== 'Other').length;
            
            modalSummary.innerHTML = `
                <strong>Summary for ${dayName}:</strong><br>
                Total ft¬≤: ${totalSqft.toLocaleString()}<br>
                Top Customer: ${topCustomer ? topCustomer.label : 'N/A'} (${topCustomer ? topCustomer.percentage : '0'}%)<br>
                Individual Customers Shown: ${individualCustomers}<br>
                ${otherCategory ? `Other Customers: ${otherCategory.percentage}%` : ''}
            `;
            
            // Create pie chart
            if (customerModalChart) {
                customerModalChart.destroy();
            }
            
            const colors = [
                '#3b82f6', '#a855f7', '#10b981', '#f59e0b', '#ef4444', 
                '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#84cc16',
                '#06b6d4', '#8b5a2b', '#dc2626', '#7c3aed', '#059669',
                '#6b7280'  // Gray color for "Other" category
            ];
            
            customerModalChart = new Chart(document.getElementById('customerPieChart'), {
                type: 'pie',
                data: {
                    labels: pieData.map(item => item.label),
                    datasets: [{
                        data: pieData.map(item => item.value),
                        backgroundColor: colors.slice(0, pieData.length),
                        borderColor: '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'right',
                            labels: {
                                usePointStyle: true,
                                padding: 15,
                                font: { size: 12 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const item = pieData[context.dataIndex];
                                    return `${item.label}: ${item.value.toLocaleString()} ft¬≤ (${item.percentage}%)`;
                                }
                            }
                        }
                    }
                }
            });
            
            modal.style.display = 'block';
        }
        
        function closeModal() {
            const modal = document.getElementById('customerModal');
            modal.style.display = 'none';
            if (customerModalChart) {
                customerModalChart.destroy();
                customerModalChart = null;
            }
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('customerModal');
            if (event.target === modal) {
                closeModal();
            }
        }

        /* ========================================
           TAB NAVIGATION
           ======================================== */
        
        /**
         * Switches between Dashboard and TTM Analytics tabs
         * Updates button states and content visibility
         * Refreshes charts for the active tab
         * 
         * @param {string} tabId - ID of tab to show ('dashboard' or 'analytics')
         * 
         * To add a new tab:
         * 1. Add tab button in HTML with onclick="showTab('newtab')"
         * 2. Add tab content div with id="newtab-tab" and class="tab-content"
         * 3. Add condition here to update charts for new tab if needed
         */
        function showTab(tabId) {
            // Deactivate all tab buttons
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                // Activate button matching the selected tab
                if (btn.textContent.toLowerCase().includes(tabId)) {
                    btn.classList.add('active');
                }
            });

            // Hide all tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            // Show selected tab content
            document.getElementById(`${tabId}-tab`).classList.add('active');

            // Refresh charts for the active tab
            if (tabId === 'analytics') {
                updateAnalytics();  // Update TTM Analytics charts
            } else {
                updateDashboard();  // Update Dashboard charts
            }
        }

        /* ========================================
           TTM ANALYTICS - CHECKBOX MANAGEMENT
           ======================================== */
        
        /**
         * Populates the TTM selector checkboxes in the Analytics tab
         * Pre-selects pickers from the Pickers sheet on first load
         * 
         * Selection behavior:
         * - First time: Pre-selects only TTMs listed in Pickers sheet
         * - If no Pickers sheet: Selects all TTMs by default
         * - After first load: Maintains user's checkbox selections
         * 
         * To change default selection behavior:
         * - Remove the allPickers check to always select all TTMs
         * - Add additional criteria (e.g., only TTMs with sqft > 5000)
         */
        function populateTTMCheckboxes() {
            const filteredData = getFilteredData();
            
            // Aggregate square footage by TTM name
            const ttmData = {};
            filteredData.forEach(row => {
                if (!ttmData[row.name]) {
                    ttmData[row.name] = 0;
                }
                ttmData[row.name] += row.sqft;
            });
            
            // Get unique TTM names sorted alphabetically
            const ttmNames = Object.keys(ttmData).sort((a, b) => a.localeCompare(b));
            
            // On first load, pre-select pickers if available
            if (selectedTTMs.size === 0) {
                if (allPickers && allPickers.length > 0) {
                    // Pre-select only TTMs listed in Pickers sheet
                    ttmNames.forEach(name => {
                        if (allPickers.includes(name)) {
                            selectedTTMs.add(name);
                        }
                    });
                } else {
                    // No pickers data available - select all TTMs
                    ttmNames.forEach(name => selectedTTMs.add(name));
                }
            }
            
            // Clear and rebuild checkbox container
            const container = document.getElementById('ttmCheckboxes');
            container.innerHTML = '';
            
            ttmNames.forEach(name => {
                const div = document.createElement('div');
                div.className = 'ttm-checkbox';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `ttm-${name.replace(/\s+/g, '-')}`;
                checkbox.value = name;
                checkbox.checked = selectedTTMs.has(name);
                checkbox.onchange = function() {
                    if (this.checked) {
                        selectedTTMs.add(name);
                    } else {
                        selectedTTMs.delete(name);
                    }
                    updateTTMChart();
                };
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = name;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
        }

        function selectAllTTMs() {
            const checkboxes = document.querySelectorAll('#ttmCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                selectedTTMs.add(cb.value);
            });
            updateTTMChart();
        }

        function deselectAllTTMs() {
            const checkboxes = document.querySelectorAll('#ttmCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                selectedTTMs.delete(cb.value);
            });
            updateTTMChart();
        }

        function populateEmployeeCheckboxes(employeeNames) {
            const container = document.getElementById('employeeCheckboxes');
            
            // Only populate once or when employee list changes
            if (container.children.length > 0) {
                return;
            }
            
            // If this is the first time, select only pickers (if available), otherwise select all
            if (selectedEmployees.size === 0) {
                if (allPickers && allPickers.length > 0) {
                    // Pre-select only pickers
                    employeeNames.forEach(name => {
                        if (allPickers.includes(name)) {
                            selectedEmployees.add(name);
                        }
                    });
                } else {
                    // No pickers data, select all
                    employeeNames.forEach(name => selectedEmployees.add(name));
                }
            }
            
            container.innerHTML = '';
            
            employeeNames.forEach(name => {
                const div = document.createElement('div');
                div.className = 'ttm-checkbox';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `emp-${name.replace(/\s+/g, '-')}`;
                checkbox.value = name;
                checkbox.checked = selectedEmployees.has(name);
                checkbox.onchange = function() {
                    if (this.checked) {
                        selectedEmployees.add(name);
                    } else {
                        selectedEmployees.delete(name);
                    }
                    updateDashboard();
                };
                
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = name;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            });
        }

        function selectAllEmployees() {
            const checkboxes = document.querySelectorAll('#employeeCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                selectedEmployees.add(cb.value);
            });
            updateDashboard();
        }

        function deselectAllEmployees() {
            const checkboxes = document.querySelectorAll('#employeeCheckboxes input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                selectedEmployees.delete(cb.value);
            });
            updateDashboard();
        }

        function updateAnalytics() {
            populateTTMCheckboxes();
            updateTTMChart();
        }

        function updateTTMChart() {
            const filteredData = getFilteredData();
            
            // Aggregate ft¬≤ by TTM
            const ttmData = {};
            filteredData.forEach(row => {
                if (!ttmData[row.name]) {
                    ttmData[row.name] = 0;
                }
                ttmData[row.name] += row.sqft;
            });
            
            // Convert to array and sort alphabetically
            let ttmArray = Object.keys(ttmData).map(name => ({
                name: name,
                sqft: ttmData[name]
            })).sort((a, b) => a.name.localeCompare(b.name));
            
            // Filter to only show selected TTMs
            ttmArray = ttmArray.filter(item => selectedTTMs.has(item.name));
            
            // Calculate median ONLY from selected TTMs (excluding values below 2000)
            const validSqftValues = ttmArray
                .map(item => item.sqft)
                .filter(sqft => sqft >= 2000)
                .sort((a, b) => a - b);
            
            let median = 0;
            if (validSqftValues.length > 0) {
                const mid = Math.floor(validSqftValues.length / 2);
                if (validSqftValues.length % 2 === 0) {
                    median = (validSqftValues[mid - 1] + validSqftValues[mid]) / 2;
                } else {
                    median = validSqftValues[mid];
                }
            }
            
            // Calculate percentage difference from median for each TTM
            const percentDifferences = ttmArray.map(item => {
                if (median === 0) return 0;
                return ((item.sqft - median) / median) * 100;
            });
            
            // Prepare chart data
            const labels = ttmArray.map(item => item.name);
            const sqftValues = ttmArray.map(item => item.sqft);
            
            // Create colors based on whether above or below median
            const barColors = sqftValues.map(sqft => 
                sqft >= median ? '#10b981' : '#ef4444'
            );
            
            // Destroy existing chart if it exists
            if (ttmChart) {
                ttmChart.destroy();
            }
            
            // Create the chart
            const ctx = document.getElementById('ttmChart').getContext('2d');
            ttmChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'ft¬≤ Picked',
                            data: sqftValues,
                            backgroundColor: barColors,
                            borderRadius: 6,
                            borderWidth: 2,
                            borderColor: barColors
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const sqft = context.parsed.y;
                                    const percentDiff = percentDifferences[context.dataIndex];
                                    const sign = percentDiff >= 0 ? '+' : '';
                                    return [
                                        `ft¬≤: ${sqft.toLocaleString()}`,
                                        `Median: ${Math.round(median).toLocaleString()}`,
                                        `Difference: ${sign}${percentDiff.toFixed(1)}%`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Square Footage (ft¬≤)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toLocaleString();
                                }
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Team Members',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                font: {
                                    size: 11
                                }
                            }
                        }
                    }
                },
                plugins: [{
                    id: 'medianLinePlugin',
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const yScale = chart.scales.y;
                        
                        // Draw median line
                        const yPos = yScale.getPixelForValue(median);
                        
                        ctx.save();
                        ctx.strokeStyle = '#3b82f6';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.beginPath();
                        ctx.moveTo(chartArea.left, yPos);
                        ctx.lineTo(chartArea.right, yPos);
                        ctx.stroke();
                        ctx.restore();
                        
                        // Draw median label
                        ctx.save();
                        ctx.fillStyle = '#3b82f6';
                        ctx.font = 'bold 12px sans-serif';
                        const text = `Median: ${Math.round(median).toLocaleString()} ft¬≤`;
                        const textWidth = ctx.measureText(text).width;
                        const padding = 8;
                        const labelX = chartArea.right - textWidth - padding * 2;
                        const labelY = yPos - 20;
                        
                        // Background
                        ctx.fillRect(labelX - padding, labelY - 12, textWidth + padding * 2, 20);
                        
                        // Text
                        ctx.fillStyle = 'white';
                        ctx.fillText(text, labelX, labelY);
                        ctx.restore();
                    },
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const xScale = chart.scales.x;
                        const yScale = chart.scales.y;
                        
                        // Draw percentage labels on each bar
                        ctx.save();
                        ctx.font = 'bold 11px sans-serif';
                        ctx.textAlign = 'center';
                        
                        chart.data.labels.forEach((label, index) => {
                            const meta = chart.getDatasetMeta(0);
                            const bar = meta.data[index];
                            const percentDiff = percentDifferences[index];
                            const sign = percentDiff >= 0 ? '+' : '';
                            const text = `${sign}${percentDiff.toFixed(1)}%`;
                            
                            // Position the text above the bar
                            const x = bar.x;
                            const y = bar.y - 10;
                            
                            // Set color based on above/below median
                            ctx.fillStyle = percentDiff >= 0 ? '#10b981' : '#ef4444';
                            ctx.fillText(text, x, y);
                        });
                        
                        ctx.restore();
                    }
                }]
            });
        }

        // Initialize with sample data
        const today = new Date().toISOString().split('T')[0];
        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 29);
        document.getElementById('startDate').value = thirtyDaysAgo.toISOString().split('T')[0];
        document.getElementById('endDate').value = today;
        document.getElementById('startDate2').value = thirtyDaysAgo.toISOString().split('T')[0];
        document.getElementById('endDate2').value = today;
        
        updateDashboard();
    </script>
</body>
</html>